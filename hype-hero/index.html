<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rhythm Game - Visual FX Update</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0c0c0f; /* Um preto mais profundo */
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 2px solid #555;
            border-radius: 15px;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            text-shadow: 0 0 8px #000;
        }
        .info-box {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        #score, #combo, #song-info {
            font-size: 1.5em;
            font-weight: bold;
        }
        #combo {
            color: #00ffff;
            transition: transform 0.1s ease-out;
        }

        /* Menu Principal */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #menu-title {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 40px;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        #song-list {
            max-width: 600px;
            width: 90%;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .song-item {
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 20px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .song-item:hover {
            background-color: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            transform: scale(1.02);
        }
        
        .song-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .song-artist {
            font-size: 1.1em;
            color: #ccc;
            margin-bottom: 10px;
        }
        
        .difficulties {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .difficulty-btn {
            padding: 8px 15px;
            background-color: #444;
            border: 1px solid #666;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        
        .difficulty-btn:hover {
            background-color: #00ffff;
            color: #000;
        }
        
        .difficulty-easy { border-color: #90EE90; }
        .difficulty-medium { border-color: #FFD700; }
        .difficulty-hard { border-color: #FF6347; }
        .difficulty-expert { border-color: #FF1493; }

        /* Tela de preparação */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        #start-button {
            padding: 15px 30px;
            font-size: 1.8em;
            font-weight: bold;
            color: #1a1a1a;
            background: linear-gradient(45deg, #00ffff, #00aaff);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transition: all 0.2s ease-in-out;
        }
        #start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }
        #key-mapping {
            margin-top: 20px;
            font-size: 1.2em;
            color: #ccc;
        }

        /* Modal de pausa */
        #pause-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        
        .pause-title {
            font-size: 2.5em;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .pause-btn {
            padding: 15px 30px;
            font-size: 1.3em;
            font-weight: bold;
            background-color: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 10px;
            cursor: pointer;
            min-width: 200px;
            transition: all 0.2s ease;
        }
        
        .pause-btn:hover {
            background-color: #00ffff;
            color: #000;
            transform: scale(1.05);
        }

        /* Contagem regressiva */
        #countdown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
            backdrop-filter: blur(5px);
        }
        
        #countdown-number {
            font-size: 8em;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            animation: countdownPulse 1s ease-in-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Back button */
        #back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
            z-index: 10;
            pointer-events: auto;
        }
        
        #back-btn:hover {
            background-color: #00ffff;
            color: #000;
            border-color: #00ffff;
        }

        /* Tela de Configurações */
        #settings-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #settings-title {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 40px;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        .settings-container {
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #444;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }
        
        .setting-item {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .setting-label {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff;
        }
        
        .setting-description {
            font-size: 0.9em;
            color: #ccc;
            line-height: 1.4;
        }
        
        .setting-input {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        #audio-delay-input {
            padding: 10px 15px;
            font-size: 1.1em;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 5px;
            color: #fff;
            width: 120px;
            text-align: center;
        }
        
        #audio-delay-input:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .setting-unit {
            color: #ccc;
            font-size: 1.1em;
        }
        
        .settings-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .settings-btn {
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .settings-btn:hover {
            background-color: #00ffff;
            color: #000;
            transform: scale(1.05);
        }
        
        .settings-btn.secondary {
            border-color: #666;
            color: #ccc;
        }
        
        .settings-btn.secondary:hover {
            background-color: #666;
            color: #fff;
        }

        /* Botão de configurações no menu */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #settings-btn:hover {
            background-color: #00ffff;
            color: #000;
            border-color: #00ffff;
        }

        /* Controles Touch para Mobile */
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            z-index: 10;
            display: none;
            pointer-events: auto;
        }

        .touch-lane {
            position: absolute;
            bottom: 50px;
            width: 20%; /* 100% / 5 lanes = 20% cada */
            height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.1s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-lane.active {
            background-color: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.9);
            color: rgba(255, 255, 255, 1);
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        /* Cores específicas para cada lane quando ativa */
        .touch-lane[data-lane="0"].active {
            background-color: rgba(255, 99, 71, 0.3);
            border-color: #FF6347;
            box-shadow: 0 0 15px rgba(255, 99, 71, 0.5);
        }

        .touch-lane[data-lane="1"].active {
            background-color: rgba(144, 238, 144, 0.3);
            border-color: #90EE90;
            box-shadow: 0 0 15px rgba(144, 238, 144, 0.5);
        }

        .touch-lane[data-lane="2"].active {
            background-color: rgba(173, 216, 230, 0.3);
            border-color: #ADD8E6;
            box-shadow: 0 0 15px rgba(173, 216, 230, 0.5);
        }

        .touch-lane[data-lane="3"].active {
            background-color: rgba(255, 215, 0, 0.3);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .touch-lane[data-lane="4"].active {
            background-color: rgba(218, 112, 214, 0.3);
            border-color: #DA70D6;
            box-shadow: 0 0 15px rgba(218, 112, 214, 0.5);
        }

        /* Media queries para dispositivos móveis */
        @media (max-width: 768px) {
            body {
                height: 100vh;
                height: 100dvh; /* Para melhor suporte em móveis */
            }

            #game-container {
                border: none;
                border-radius: 0;
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                max-width: 100vw;
                overflow-x: hidden;
            }

            canvas {
                width: 100% !important;
                max-width: 100vw;
                height: auto;
            }

            #menu-title {
                font-size: 2.5em;
                margin-bottom: 30px;
            }

            #song-list {
                width: 95%;
                max-height: 50vh;
            }

            .song-item {
                padding: 15px;
                margin: 8px 0;
            }

            .song-title {
                font-size: 1.3em;
            }

            .song-artist {
                font-size: 1em;
            }

            #ui-container {
                top: 10px;
                left: 10px;
                right: 10px;
            }

            .info-box {
                padding: 8px 12px;
            }

            #score, #combo, #song-info {
                font-size: 1.2em;
            }

            #start-button {
                padding: 12px 25px;
                font-size: 1.5em;
            }

            #key-mapping {
                font-size: 1em;
                text-align: center;
                margin-top: 15px;
            }

            /* Mostrar controles touch em mobile */
            #touch-controls {
                display: block;
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            #menu-title {
                font-size: 2em;
                margin-bottom: 20px;
            }

            .song-title {
                font-size: 1.2em;
            }

            #score, #combo, #song-info {
                font-size: 1em;
            }

            .info-box {
                padding: 6px 10px;
            }

            .touch-lane {
                font-size: 1.5em;
            }
        }

        /* Detectar orientação landscape em mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            #menu-title {
                font-size: 1.8em;
                margin-bottom: 15px;
            }

            #song-list {
                max-height: 40vh;
            }

            #touch-controls {
                height: 120px;
            }

            .touch-lane {
                height: 100px;
                bottom: 10px;
                font-size: 1.3em;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Menu Principal -->
        <div id="main-menu">
            <h1 id="menu-title">RHYTHM GAME</h1>
            <div id="song-list">
                <!-- Lista de músicas será preenchida dinamicamente -->
            </div>
            <button id="settings-btn">
                <span>⚙️</span>
                <span>Configurações</span>
            </button>
        </div>

        <!-- Tela de Configurações -->
        <div id="settings-screen">
            <h1 id="settings-title">CONFIGURAÇÕES</h1>
            <div class="settings-container">
                <div class="setting-item">
                    <div class="setting-label">Delay de Áudio</div>
                    <div class="setting-description">
                        Ajuste o delay para sincronizar o áudio com o visual. 
                        Use valores positivos se o áudio estiver atrasado, 
                        negativos se estiver adiantado.
                    </div>
                    <div class="setting-input">
                        <input type="number" id="audio-delay-input" value="40" min="-500" max="500" step="10">
                        <span class="setting-unit">ms</span>
                    </div>
                </div>
                
                <div class="settings-buttons">
                    <button class="settings-btn" id="save-settings-btn">Salvar</button>
                    <button class="settings-btn secondary" id="cancel-settings-btn">Cancelar</button>
                </div>
            </div>
        </div>

        <!-- Tela de preparação -->
        <div id="start-screen">
            <h1 id="start-title"></h1>
            <h2 id="start-artist" style="color: #ccc; margin-top: -10px;"></h2>
            <h3 id="start-difficulty" style="color: #FFD700; margin-top: 10px;"></h3>
            <button id="start-button">Iniciar</button>
            <p id="key-mapping"></p>
        </div>

        <!-- Modal de pausa -->
        <div id="pause-modal">
            <div class="pause-title">JOGO PAUSADO</div>
            <div class="pause-buttons">
                <button class="pause-btn" id="resume-btn">Resumir</button>
                <button class="pause-btn" id="restart-btn">Recomeçar</button>
                <button class="pause-btn" id="exit-btn">Sair</button>
            </div>
        </div>

        <!-- Contagem regressiva -->
        <div id="countdown">
            <div id="countdown-number">3</div>
        </div>

        <!-- Botão voltar (visível durante o jogo) -->
        <button id="back-btn" style="display: none;">← Voltar</button>

        <div id="ui-container">
            <div class="info-box">
                <div id="song-info">Carregando...</div>
            </div>
            <div class="info-box" style="text-align: right;">
                <div id="score">Score: 0</div>
                <div id="combo">Combo: 0</div>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
        
        <!-- Controles Touch para Mobile -->
        <div id="touch-controls">
            <div class="touch-lane" data-lane="0" style="left: 0%; border-color: #FF6347;">D</div>
            <div class="touch-lane" data-lane="1" style="left: 20%; border-color: #90EE90;">F</div>
            <div class="touch-lane" data-lane="2" style="left: 40%; border-color: #ADD8E6;">J</div>
            <div class="touch-lane" data-lane="3" style="left: 60%; border-color: #FFD700;">K</div>
            <div class="touch-lane" data-lane="4" style="left: 80%; border-color: #DA70D6;">L</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.9/browser/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <script>
        // Variáveis globais para armazenar os dados
        let chartData = null;
        let currentSong = null;
        let currentDifficulty = null;
        let gameState = 'menu'; // 'menu', 'preparing', 'countdown', 'playing', 'paused'

        // --- Configurações do Jogo ---
        const NUM_LANES = 5;
        // Calcula largura responsiva: em mobile usa 90% da largura da tela, em desktop usa 100px por lane
        const SCREEN_WIDTH = window.innerWidth;
        const IS_MOBILE_SIZE = SCREEN_WIDTH <= 768;
        const LANE_WIDTH = IS_MOBILE_SIZE ? Math.floor((SCREEN_WIDTH * 0.9) / NUM_LANES) : 100;
        const NOTE_HEIGHT = 25;
        const GAME_WIDTH = LANE_WIDTH * NUM_LANES;
        const GAME_HEIGHT = window.innerHeight * 0.95;
        const NOTE_SPEED = 0.6;
        
        // Configurações de efeitos visuais
        const STAR_SPEED_TRANSITION_RATE = 0.2;
        
        // Janelas de tempo para acerto (em ms)
        const HIT_WINDOWS = {
            PERFECT: 35,
            GOOD: 70,
            FAIR: 100,
        };
        const SCORE_VALUES = { PERFECT: 300, GOOD: 200, FAIR: 100, MISS: 0 };

        const LANE_COLORS = [0xFF6347, 0x90EE90, 0xADD8E6, 0xFFD700, 0xDA70D6];
        const KEY_MAPPINGS = ['d', 'f', 'j', 'k', 'l'];

        // --- Variáveis de Estado do Jogo ---
        let score = 0, combo = 0;
        let pixiApp, noteContainer, targetContainer, feedbackContainer, particleContainer, backgroundContainer;
        let notesOnScreen = [], targets = [], particles = [], stars = [];
        let gameStartTime = 0;
        let mainTargetLine, glowBorder;
        let keysPressed = new Set();
        let starSpeedMultiplier = 1.0;
        let currentPlayer = null;

        // --- Variáveis do Visualizador de Música ---
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let bufferLength = 0;
        let visualizerContainer = null;

        // --- Variáveis para Dispositivos Móveis ---
        let isMobile = false;
        let touchLanes = [];
        let touchStates = new Set(); // Para rastrear toques ativos
        let visualizerBars = [];
        let visualizerTargetHeights = []; // Para suavização das transições
        const VISUALIZER_BARS = 10; // Reduzido para apenas 10 barras
        const VISUALIZER_BAR_WIDTH = GAME_WIDTH / VISUALIZER_BARS; // Distribui por toda a largura
        const VISUALIZER_MAX_HEIGHT = GAME_HEIGHT; // Altura máxima = altura total da tela
        const VISUALIZER_MIN_HEIGHT = GAME_HEIGHT / 4; // Altura mínima = 1/4 da altura total
        const VISUALIZER_SMOOTHING = 0.15; // Constante para suavização das transições (0.1 = mais suave, 0.3 = mais rápido)

        // --- Configurações do Jogo (persistentes) ---
        let gameSettings = {
            audioDelay: 0 // Delay de áudio em milissegundos
        };

        // --- Elementos da UI ---
        const scoreText = document.getElementById('score');
        const comboText = document.getElementById('combo');
        const songInfoText = document.getElementById('song-info');
        const mainMenu = document.getElementById('main-menu');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const startTitle = document.getElementById('start-title');
        const startArtist = document.getElementById('start-artist');
        const startDifficulty = document.getElementById('start-difficulty');
        const keyMappingText = document.getElementById('key-mapping');
        const pauseModal = document.getElementById('pause-modal');
        const countdown = document.getElementById('countdown');
        const countdownNumber = document.getElementById('countdown-number');
        const backBtn = document.getElementById('back-btn');
        const songList = document.getElementById('song-list');
        const settingsScreen = document.getElementById('settings-screen');
        const settingsBtn = document.getElementById('settings-btn');
        const audioDelayInput = document.getElementById('audio-delay-input');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const cancelSettingsBtn = document.getElementById('cancel-settings-btn');

        // Dados das músicas disponíveis
        const AVAILABLE_SONGS = [
            {
                id: "song_003",
                title: "Reaching Saturn",
                artist: "Depths Of Titan", 
                filename: "003_reaching-saturn-depths-of-titan.mp3",
                difficulties: [
                    { name: "Difícil", level: "hard", chartFile: "charts/003_reaching-saturn-depths-of-titan_medium.json" }
                ]
            },
            {
                id: "song_004",
                title: "Dia Delícia",
                artist: "Nakama", 
                filename: "004_dia-delicia-nakama.mp3",
                difficulties: [
                    { name: "Difícil", level: "hard", chartFile: "charts/004_dia-delicia-nakama_medium.json" }
                ]
            },
            {
                id: "song_005",
                title: "Passo Bem Solto (Slowed)",
                artist: "ATLSX", 
                filename: "005_passo-bem-solto-atlxs-slowed.mp3",
                difficulties: [
                    { name: "Médio", level: "medium", chartFile: "charts/005_passo-bem-solto-atlxs-slowed_medium.json" }
                ]
            }
        ];

        // --- Funções de Configurações ---
        function loadSettings() {
            const saved = localStorage.getItem('rhythmGameSettings');
            if (saved) {
                try {
                    gameSettings = { ...gameSettings, ...JSON.parse(saved) };
                } catch (e) {
                    console.warn('Erro ao carregar configurações:', e);
                }
            }
            audioDelayInput.value = gameSettings.audioDelay;
        }

        function saveSettings() {
            const newDelay = parseInt(audioDelayInput.value) || 0;
            
            // Valida o range do delay
            if (newDelay < -500 || newDelay > 500) {
                alert('O delay deve estar entre -500ms e 500ms');
                return;
            }
            
            gameSettings.audioDelay = newDelay;
            
            try {
                localStorage.setItem('rhythmGameSettings', JSON.stringify(gameSettings));
                closeSettings();
                
                // Feedback visual
                saveSettingsBtn.textContent = 'Salvo!';
                setTimeout(() => {
                    saveSettingsBtn.textContent = 'Salvar';
                }, 1000);
            } catch (e) {
                console.warn('Erro ao salvar configurações:', e);
                alert('Erro ao salvar configurações');
            }
        }

        function openSettings() {
            gameState = 'settings';
            mainMenu.style.display = 'none';
            settingsScreen.style.display = 'flex';
            audioDelayInput.value = gameSettings.audioDelay;
        }

        function closeSettings() {
            gameState = 'menu';
            settingsScreen.style.display = 'none';
            mainMenu.style.display = 'flex';
        }

        // --- Funções para Dispositivos Móveis ---
        function detectMobile() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Detecta dispositivos móveis baseado no user agent e tamanho da tela
            const isMobileUA = /android|avantgo|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(userAgent);
            const isSmallScreen = window.innerWidth <= 768;
            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            return isMobileUA || (isSmallScreen && hasTouch);
        }

        function initMobileControls() {
            isMobile = detectMobile();
            
            if (isMobile) {
                // Obtém referências aos elementos das lanes touch
                touchLanes = Array.from(document.querySelectorAll('.touch-lane'));
                
                // Configura os event listeners para touch
                setupTouchEventListeners();
                
                console.log('Modo mobile ativado');
            } else {
                // Oculta os controles touch em desktop
                document.getElementById('touch-controls').style.display = 'none';
            }
        }

        function setupTouchEventListeners() {
            // Previne scroll e zoom em dispositivos móveis durante o jogo
            document.addEventListener('touchstart', (e) => {
                if (gameState === 'playing') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (gameState === 'playing') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            touchLanes.forEach((lane, index) => {
                // Touch start
                lane.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleTouchStart(index);
                }, { passive: false });
                
                // Touch end
                lane.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleTouchEnd(index);
                }, { passive: false });
                
                // Touch cancel (quando o toque é interrompido)
                lane.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    handleTouchEnd(index);
                }, { passive: false });
                
                // Adiciona também mouse events para teste em desktop
                lane.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    handleTouchStart(index);
                });
                
                lane.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    handleTouchEnd(index);
                });
                
                // Evita o menu de contexto no mobile
                lane.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            });
        }

        function handleTouchStart(laneIndex) {
            if (gameState !== 'playing') return;
            
            // Adiciona à lista de toques ativos
            touchStates.add(laneIndex);
            
            // Feedback visual da lane touch
            const lane = touchLanes[laneIndex];
            if (lane) {
                lane.classList.add('active');
            }
            
            // Processa o input da lane
            triggerLaneInput(laneIndex);
        }

        function handleTouchEnd(laneIndex) {
            // Remove da lista de toques ativos
            touchStates.delete(laneIndex);
            
            // Remove feedback visual
            const lane = touchLanes[laneIndex];
            if (lane) {
                lane.classList.remove('active');
            }
        }

        function checkNoteHit(laneIndex) {
            const elapsedTime = (Tone.Transport.seconds * 1000) + gameSettings.audioDelay;
            let noteToHit = null;
            let closestTimeDiff = Infinity;

            for (const note of notesOnScreen) {
                if (note.lane === laneIndex && !note.hit) {
                    const timeDiff = Math.abs(note.time - elapsedTime);
                    if (timeDiff < HIT_WINDOWS.FAIR && timeDiff < closestTimeDiff) {
                        noteToHit = note;
                        closestTimeDiff = timeDiff;
                    }
                }
            }

            if (noteToHit) {
                handleHit(noteToHit, closestTimeDiff);
            }
        }

        function triggerLaneInput(laneIndex) {
            if (gameState !== 'playing') return;
            
            // Feedback visual do target
            const target = targets[laneIndex];
            if (target) {
                target.alpha = 1.0;
                setTimeout(() => { 
                    if (target && !target.destroyed) target.alpha = 0.5; 
                }, 150);
            }
            
            // Verifica hit nas notas
            checkNoteHit(laneIndex);
        }

        // --- Inicialização ---
        window.onload = function() {
            setupPixi();
            populateSongList();
            setupEventListeners();
            loadSettings();
            initMobileControls();
            
            // Define o texto de instrução baseado no dispositivo
            if (isMobile) {
                keyMappingText.textContent = 'Toque nas áreas coloridas na parte inferior da tela';
            } else {
                keyMappingText.textContent = `Teclas: ${KEY_MAPPINGS.join(', ').toUpperCase()}`;
            }
        };

        function setupEventListeners() {
            // Botões da tela de preparação
            startButton.onclick = startCountdown;
            
            // Botões do modal de pausa
            document.getElementById('resume-btn').onclick = resumeGame;
            document.getElementById('restart-btn').onclick = restartGame;
            document.getElementById('exit-btn').onclick = exitToMenu;
            
            // Botão voltar
            backBtn.onclick = exitToMenu;
            
            // Botões de configurações
            settingsBtn.onclick = openSettings;
            saveSettingsBtn.onclick = saveSettings;
            cancelSettingsBtn.onclick = closeSettings;
            
            // Teclas globais
            document.addEventListener('keydown', handleGlobalKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Listener para redimensionamento da tela
            window.addEventListener('resize', handleResize);
        }

        function handleResize() {
            // Recalcula dimensões para dispositivos móveis
            const newScreenWidth = window.innerWidth;
            const newIsMobileSize = newScreenWidth <= 768;
            
            if (newIsMobileSize !== IS_MOBILE_SIZE) {
                // Se mudou entre mobile e desktop, recarrega a página para recalcular tudo
                location.reload();
            } else if (pixiApp && newIsMobileSize) {
                // Se continua em mobile, apenas redimensiona o canvas
                const newLaneWidth = Math.floor((newScreenWidth * 0.9) / NUM_LANES);
                const newGameWidth = newLaneWidth * NUM_LANES;
                const newGameHeight = window.innerHeight * 0.95;
                
                pixiApp.renderer.resize(newGameWidth, newGameHeight);
            }
        }

        function populateSongList() {
            songList.innerHTML = '';
            
            AVAILABLE_SONGS.forEach(song => {
                const songItem = document.createElement('div');
                songItem.className = 'song-item';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'song-title';
                titleDiv.textContent = song.title;
                
                const artistDiv = document.createElement('div');
                artistDiv.className = 'song-artist';
                artistDiv.textContent = song.artist;
                
                const difficultiesDiv = document.createElement('div');
                difficultiesDiv.className = 'difficulties';
                
                song.difficulties.forEach(difficulty => {
                    const diffBtn = document.createElement('button');
                    diffBtn.className = `difficulty-btn difficulty-${difficulty.level}`;
                    diffBtn.textContent = difficulty.name;
                    
                    if (difficulty.chartFile) {
                        diffBtn.onclick = () => selectSongAndDifficulty(song, difficulty);
                    } else {
                        diffBtn.style.opacity = '0.5';
                        diffBtn.style.cursor = 'not-allowed';
                        diffBtn.title = 'Em breve';
                    }
                    
                    difficultiesDiv.appendChild(diffBtn);
                });
                
                songItem.appendChild(titleDiv);
                songItem.appendChild(artistDiv);
                songItem.appendChild(difficultiesDiv);
                songList.appendChild(songItem);
            });
        }

        async function selectSongAndDifficulty(song, difficulty) {
            if (!difficulty.chartFile) {
                alert('Esta dificuldade ainda não está disponível!');
                return;
            }

            currentSong = song;
            currentDifficulty = difficulty;
            
            try {
                // Carrega os dados do chart
                const response = await fetch(difficulty.chartFile);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                chartData = await response.json();
                
                // Atualiza os dados da música no chart se necessário
                chartData.song.url = `songs/${song.filename}`;
                
                setupGame();
                showStartScreen();
                
            } catch (error) {
                console.error('Erro ao carregar dados do chart:', error);
                alert('Erro ao carregar os dados da música.');
            }
        }

        function setupGame() {
            if (!chartData) return;
            
            const { metadata } = chartData;
            songInfoText.textContent = `${currentSong.title} - ${currentSong.artist}`;
            startTitle.textContent = currentSong.title;
            startArtist.textContent = currentSong.artist;
            startDifficulty.textContent = `Dificuldade: ${currentDifficulty.name}`;
            
            // Reset game state
            score = 0;
            combo = 0;
            updateScore(0);
            resetCombo();
            
            // Clear previous game data
            if (notesOnScreen.length > 0) {
                notesOnScreen.forEach(note => note.destroy());
                notesOnScreen = [];
            }
            if (particles.length > 0) {
                particles.forEach(particle => particle.destroy());
                particles = [];
            }
        }

        function showStartScreen() {
            gameState = 'preparing';
            mainMenu.style.display = 'none';
            startScreen.style.display = 'flex';
            backBtn.style.display = 'block';
        }

        function setupPixi() {
            pixiApp = new PIXI.Application({
                width: GAME_WIDTH, height: GAME_HEIGHT,
                view: document.getElementById('game-canvas'),
                backgroundColor: 0x0c0c0f, antialias: true,
            });

            // Organização de camadas (de trás para frente)
            backgroundContainer = new PIXI.Container();
            visualizerContainer = new PIXI.Container();
            targetContainer = new PIXI.Container();
            noteContainer = new PIXI.Container();
            particleContainer = new PIXI.Container();
            feedbackContainer = new PIXI.Container();
            pixiApp.stage.addChild(backgroundContainer, visualizerContainer, targetContainer, noteContainer, particleContainer, feedbackContainer);

            createStarfield();
            createGlowBorder();
            createMusicVisualizer();
            drawLanes();
            drawTargets();
        }

        // --- Lógica de contagem regressiva ---
        async function startCountdown() {
            if (!chartData) return;
            
            gameState = 'countdown';
            startScreen.style.display = 'none';
            countdown.style.display = 'flex';
            
            for (let i = 3; i > 0; i--) {
                countdownNumber.textContent = i;
                countdownNumber.style.animation = 'none';
                
                // Force reflow para reiniciar a animação
                countdownNumber.offsetHeight;
                countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdown.style.display = 'none';
            startGame();
        }

        // --- Lógica do jogo ---

        async function startGame() {
            if (!chartData) return;

            gameState = 'playing';
            await Tone.start();

            // Configura o BPM do Transport
            Tone.Transport.bpm.value = chartData.metadata.bpm;

            currentPlayer = new Tone.Player(chartData.song.url).toDestination();
            await Tone.loaded();
            
            // Configura o analisador de áudio para o visualizador
            setupAudioAnalyser();
            
            // Aplica o delay de áudio configurado
            const audioDelay = gameSettings.audioDelay / 1000; // Converte ms para segundos
            
            // Inicia o Transport e o player com delay
            Tone.Transport.start();
            if (audioDelay !== 0) {
                // Se há delay positivo, atrasa o áudio
                // Se há delay negativo, adianta o áudio
                currentPlayer.start(0, Math.abs(audioDelay) * (audioDelay < 0 ? 1 : 0));
                
                // Ajusta o tempo de início das notas baseado no delay
                gameStartTime = performance.now() - (audioDelay * 1000);
            } else {
                currentPlayer.start();
                gameStartTime = performance.now();
            }

            chartData.notes.forEach(createNote);
            pixiApp.ticker.add(gameLoop);
        }

        function pauseGame() {
            if (gameState !== 'playing') return;
            
            gameState = 'paused';
            Tone.Transport.pause();
            if (currentPlayer) {
                currentPlayer.stop();
            }
            pauseModal.style.display = 'flex';
        }

        async function resumeGame() {
            if (gameState !== 'paused') return;
            
            pauseModal.style.display = 'none';
            
            // Contagem regressiva antes de resumir
            countdown.style.display = 'flex';
            
            for (let i = 3; i > 0; i--) {
                countdownNumber.textContent = i;
                countdownNumber.style.animation = 'none';
                countdownNumber.offsetHeight;
                countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdown.style.display = 'none';
            gameState = 'playing';
            
            // Resume o Transport (que mantém os agendamentos sincronizados automaticamente)
            const currentTime = Tone.Transport.seconds;
            Tone.Transport.start();
            if (currentPlayer) {
                currentPlayer.start(0, currentTime);
            }
        }

        function restartGame() {
            pauseModal.style.display = 'none';
            stopGame();
            showStartScreen();
        }

        function exitToMenu() {
            stopGame();
            pauseModal.style.display = 'none';
            startScreen.style.display = 'none';
            countdown.style.display = 'none';
            backBtn.style.display = 'none';
            mainMenu.style.display = 'flex';
            gameState = 'menu';
        }

        function stopGame() {
            if (currentPlayer) {
                currentPlayer.stop();
                currentPlayer = null;
            }
            Tone.Transport.stop();
            Tone.Transport.cancel();
            
            // Limpa o analisador de áudio
            analyser = null;
            dataArray = null;
            
            if (pixiApp && pixiApp.ticker) {
                pixiApp.ticker.remove(gameLoop);
            }
            
            // Clear game objects
            if (notesOnScreen.length > 0) {
                notesOnScreen.forEach(note => note.destroy());
                notesOnScreen = [];
            }
            if (particles.length > 0) {
                particles.forEach(particle => particle.destroy());
                particles = [];
            }
            if (feedbackContainer) {
                feedbackContainer.removeChildren();
            }
            
            // Reset visualizer bars
            visualizerBars.forEach(bar => {
                bar.currentHeight = VISUALIZER_MIN_HEIGHT;
                bar.clear();
                bar.beginFill(0x00FFFF, 0.05); // Muito translúcido quando resetado
                bar.drawRect(0, 0, VISUALIZER_BAR_WIDTH, VISUALIZER_MIN_HEIGHT);
                bar.endFill();
                bar.y = GAME_HEIGHT - VISUALIZER_MIN_HEIGHT;
            });
        }

        function handleGlobalKeyDown(e) {
            if (e.key === 'Escape') {
                if (gameState === 'playing') {
                    pauseGame();
                    return;
                } else if (gameState === 'settings') {
                    closeSettings();
                    return;
                }
            }
            
            if (gameState === 'playing') {
                handleKeyDown(e);
            }
        }

        // --- Resto das funções do jogo (desenho, efeitos, etc.) ---
        function createStarfield() {
            for (let i = 0; i < 200; i++) {
                const star = new PIXI.Graphics();
                star.beginFill(0xFFFFFF, Math.random() * 0.8 + 0.2);
                star.drawCircle(0, 0, Math.random() * 1.5 + 0.5);
                star.endFill();
                star.x = Math.random() * GAME_WIDTH;
                star.y = Math.random() * GAME_HEIGHT;
                star.speed = Math.random() * 0.2 + 0.1;
                stars.push(star);
                backgroundContainer.addChild(star);
            }
        }

        function createGlowBorder() {
            glowBorder = new PIXI.Graphics();
            glowBorder.alpha = 0.3;
            backgroundContainer.addChild(glowBorder);
            updateGlowBorder();
        }

        function updateGlowBorder() {
            if (!glowBorder) return;
            
            glowBorder.clear();
            
            const glowLayers = [
                { thickness: 50, alpha: 0.08 },
                { thickness: 40, alpha: 0.12 },
                { thickness: 30, alpha: 0.16 },
                { thickness: 22, alpha: 0.20 },
                { thickness: 15, alpha: 0.25 },
                { thickness: 10, alpha: 0.30 },
                { thickness: 6, alpha: 0.35 }
            ];
            
            glowLayers.forEach(layer => {
                const adjustedAlpha = layer.alpha * glowBorder.alpha;
                
                glowBorder.beginFill(0x00FFFF, adjustedAlpha);
                glowBorder.drawRect(0, 0, GAME_WIDTH, layer.thickness);
                glowBorder.drawRect(0, GAME_HEIGHT - layer.thickness, GAME_WIDTH, layer.thickness);
                glowBorder.drawRect(0, 0, layer.thickness, GAME_HEIGHT);
                glowBorder.drawRect(GAME_WIDTH - layer.thickness, 0, layer.thickness, GAME_HEIGHT);
                glowBorder.endFill();
            });
        }

        function createMusicVisualizer() {
            // Inicializa o array de alturas alvo para suavização
            visualizerTargetHeights = new Array(VISUALIZER_BARS).fill(VISUALIZER_MIN_HEIGHT);
            
            // Cria as barras verticais na parte inferior da tela
            for (let i = 0; i < VISUALIZER_BARS; i++) {
                const bar = new PIXI.Graphics();
                bar.beginFill(0x00FFFF, 0.15); // Mais translúcido
                bar.drawRect(0, 0, VISUALIZER_BAR_WIDTH, VISUALIZER_MIN_HEIGHT);
                bar.endFill();
                
                // Posiciona a barra na parte inferior da tela
                bar.x = i * VISUALIZER_BAR_WIDTH;
                bar.y = GAME_HEIGHT - VISUALIZER_MIN_HEIGHT;
                
                // Armazena a altura atual para suavização
                bar.currentHeight = VISUALIZER_MIN_HEIGHT;
                
                visualizerBars.push(bar);
                visualizerContainer.addChild(bar);
            }
        }

        function setupAudioAnalyser() {
            try {
                // Usa o contexto de áudio do Tone.js
                audioContext = Tone.context;
                
                // Cria o analisador de áudio
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 128; // Resulta em 64 bins de frequência
                analyser.smoothingTimeConstant = 0.6; // Menos suavização para mais responsividade
                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                // Conecta o player do Tone.js ao analisador
                if (currentPlayer) {
                    currentPlayer.connect(analyser);
                    // Também mantém a conexão com o destination para o áudio sair
                    currentPlayer.connect(Tone.Destination);
                }
            } catch (error) {
                console.warn('Erro ao configurar analisador de áudio:', error);
            }
        }

        function updateMusicVisualizer() {
            if (!analyser || !dataArray || gameState !== 'playing') {
                // Se não há análise de áudio, mostra barras estáticas mínimas
                visualizerBars.forEach((bar, i) => {
                    // Suaviza para a altura mínima
                    bar.currentHeight += (VISUALIZER_MIN_HEIGHT - bar.currentHeight) * VISUALIZER_SMOOTHING;
                    
                    bar.clear();
                    bar.beginFill(0x00FFFF, 0.05); // Muito translúcido quando parado
                    bar.drawRect(0, 0, VISUALIZER_BAR_WIDTH, bar.currentHeight);
                    bar.endFill();
                    bar.y = GAME_HEIGHT - bar.currentHeight;
                });
                return;
            }
            
            // Obtém os dados de frequência
            analyser.getByteFrequencyData(dataArray);
            
            // Atualiza cada barra do visualizador
            for (let i = 0; i < visualizerBars.length; i++) {
                const bar = visualizerBars[i];
                
                // Distribui melhor as frequências para cobrir todo o espectro
                let frequency = 0;
                
                if (i < VISUALIZER_BARS - 2) {
                    // Para as primeiras 8 barras, mapeia linearmente
                    const frequencyIndex = Math.floor((i / (VISUALIZER_BARS - 2)) * (bufferLength * 0.6));
                    frequency = dataArray[frequencyIndex] || 0;
                } else {
                    // Para as últimas 2 barras, pega frequências mais altas
                    const startIndex = Math.floor(bufferLength * 0.6);
                    const endIndex = bufferLength - 1;
                    const rangeIndex = i - (VISUALIZER_BARS - 2);
                    const frequencyIndex = startIndex + Math.floor((rangeIndex / 1) * (endIndex - startIndex));
                    frequency = dataArray[frequencyIndex] || 0;
                    
                    // Amplifica as frequências altas para melhor visibilidade
                    frequency = Math.min(255, frequency * 2.0); // Aumentado de 1.5 para 2.0
                }
                
                // Amplifica a resposta da frequência para mais reatividade
                const amplifiedFrequency = Math.pow(frequency / 255, 0.4) * 255;
                
                // Calcula a altura alvo
                const targetHeight = VISUALIZER_MIN_HEIGHT + 
                    (amplifiedFrequency / 255) * (VISUALIZER_MAX_HEIGHT - VISUALIZER_MIN_HEIGHT);
                
                // Suaviza a transição para a altura alvo
                if (!bar.currentHeight) bar.currentHeight = VISUALIZER_MIN_HEIGHT;
                bar.currentHeight += (targetHeight - bar.currentHeight) * VISUALIZER_SMOOTHING;
                
                const barHeight = Math.max(VISUALIZER_MIN_HEIGHT, bar.currentHeight);
                
                // Atualiza a altura da barra (crescendo para cima)
                bar.clear();
                
                // Cor baseada na intensidade da frequência
                const intensity = amplifiedFrequency / 255;
                const hue = (i / VISUALIZER_BARS) * 360; // Cor baseada na posição
                const saturation = 40 + (intensity * 50); // Saturação baseada na intensidade
                const lightness = 30 + (intensity * 50); // Luminosidade baseada na intensidade
                
                // Converte HSL para RGB hex
                const color = hslToHex(hue, saturation, lightness);
                
                // Alpha varia de acordo com a altura da barra
                const heightRatio = (barHeight - VISUALIZER_MIN_HEIGHT) / (VISUALIZER_MAX_HEIGHT - VISUALIZER_MIN_HEIGHT);
                const alpha = 0.05 + (heightRatio * 0.25); // Alpha baseado na altura (0.05 a 0.3)
                
                bar.beginFill(color, alpha);
                bar.drawRect(0, 0, VISUALIZER_BAR_WIDTH, barHeight);
                bar.endFill();
                
                // Posiciona a barra para que cresça de baixo para cima
                bar.y = GAME_HEIGHT - barHeight;
            }
        }

        // Função auxiliar para converter HSL para HEX
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return parseInt(`0x${f(0)}${f(8)}${f(4)}`);
        }

        function drawLanes() {
            // Desenha overlays coloridos sob cada lane
            for (let i = 0; i < NUM_LANES; i++) {
                const laneOverlay = new PIXI.Graphics();
                laneOverlay.beginFill(LANE_COLORS[i], 0.08);
                laneOverlay.drawRect(i * LANE_WIDTH, 0, LANE_WIDTH, GAME_HEIGHT);
                laneOverlay.endFill();
                backgroundContainer.addChild(laneOverlay);
            }
            
            // Desenha as linhas separadoras das lanes
            const graphics = new PIXI.Graphics();
            for (let i = 1; i < NUM_LANES; i++) {
                graphics.lineStyle(2, 0x444444, 0.5);
                graphics.moveTo(i * LANE_WIDTH, 0);
                graphics.lineTo(i * LANE_WIDTH, GAME_HEIGHT);
            }
            backgroundContainer.addChild(graphics);
        }

        function drawTargets() {
            const targetY = GAME_HEIGHT - 100;
            mainTargetLine = new PIXI.Graphics();
            mainTargetLine.lineStyle(4, 0x00FFFF, 1);
            mainTargetLine.moveTo(0, targetY);
            mainTargetLine.lineTo(GAME_WIDTH, targetY);
            mainTargetLine.pivot.set(GAME_WIDTH / 2, targetY);
            mainTargetLine.x = GAME_WIDTH / 2;
            mainTargetLine.y = targetY;
            targetContainer.addChild(mainTargetLine);

            for (let i = 0; i < NUM_LANES; i++) {
                const target = new PIXI.Graphics();
                target.beginFill(LANE_COLORS[i], 0.2);
                target.lineStyle(2, LANE_COLORS[i], 0.7);
                target.drawCircle(i * LANE_WIDTH + LANE_WIDTH / 2, targetY, LANE_WIDTH / 2 - 5);
                target.endFill();
                target.alpha = 0.5;
                targets.push(target);
                targetContainer.addChild(target);
            }
        }

        function createNote(noteData) {
            const note = new PIXI.Graphics();
            const laneX = noteData.lane * LANE_WIDTH;
            
            note.beginFill(LANE_COLORS[noteData.lane]);
            note.drawRoundedRect(5, 0, LANE_WIDTH - 10, NOTE_HEIGHT, 8);
            note.endFill();

            note.x = laneX;
            note.pivot.y = NOTE_HEIGHT / 2;
            
            note.lane = noteData.lane;
            note.time = noteData.time;
            note.hit = false;

            notesOnScreen.push(note);
            noteContainer.addChild(note);
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                const particle = new PIXI.Graphics();
                particle.beginFill(color);
                particle.drawCircle(0, 0, Math.random() * 3 + 1);
                particle.endFill();
                particle.x = x;
                particle.y = y;
                particle.vx = (Math.random() - 0.5) * 8;
                particle.vy = (Math.random() - 0.5) * 8 - 3;
                particle.alpha = 1;
                particle.life = Math.random() * 0.5 + 0.3;
                particles.push(particle);
                particleContainer.addChild(particle);
            }
        }

        function showFeedback(text, lane, color) {
            const feedbackText = new PIXI.Text(text, {
                fontFamily: 'Segoe UI', fontSize: 32, fontWeight: 'bold',
                fill: color, stroke: '#000000', strokeThickness: 4
            });
            feedbackText.anchor.set(0.5);
            feedbackText.x = lane * LANE_WIDTH + LANE_WIDTH / 2;
            feedbackText.y = GAME_HEIGHT - 150;
            feedbackText.initialY = feedbackText.y;
            feedbackText.life = 0.5;

            feedbackContainer.addChild(feedbackText);
        }

        function gameLoop(delta) {
            if (gameState !== 'playing') return;
            
            const deltaSeconds = delta / PIXI.settings.TARGET_FPMS / 1000;
            // Aplica o delay de áudio no cálculo do tempo das notas
            const elapsedTime = (Tone.Transport.seconds * 1000) + gameSettings.audioDelay;
            const targetY = GAME_HEIGHT - 100;

            // Atualiza o visualizador de música
            updateMusicVisualizer();

            // Animação de fundo - estrelas
            const targetSpeedMultiplier = keysPressed.size > 0 ? 5.0 : 1.0;
            starSpeedMultiplier += (targetSpeedMultiplier - starSpeedMultiplier) * STAR_SPEED_TRANSITION_RATE;
            
            stars.forEach(star => {
                star.y += star.speed * starSpeedMultiplier;
                if (star.y > GAME_HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * GAME_WIDTH;
                }
            });

            // Loop das notas
            for (let i = notesOnScreen.length - 1; i >= 0; i--) {
                const note = notesOnScreen[i];
                if (note.hit) continue;

                const timeDifference = note.time - elapsedTime;
                note.y = targetY - (timeDifference * NOTE_SPEED);

                if (note.y > GAME_HEIGHT) {
                    handleMiss(note);
                }
            }

            // Loop das partículas
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.alpha -= 0.04;
                p.life -= deltaSeconds;
                if (p.life <= 0) {
                    p.destroy();
                    particles.splice(i, 1);
                }
            }
            
            // Loop do texto de feedback
            for (let i = feedbackContainer.children.length - 1; i >= 0; i--) {
                const text = feedbackContainer.children[i];
                text.y -= 1;
                text.alpha -= 0.03;
                text.life -= deltaSeconds;
                if (text.life <= 0) {
                    text.destroy();
                }
            }
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            const laneIndex = KEY_MAPPINGS.indexOf(key);

            if (laneIndex !== -1) {
                keysPressed.add(key);
                
                // Processa o input da lane
                triggerLaneInput(laneIndex);
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            keysPressed.delete(key);
        }

        function handleHit(note, timeDiff) {
            note.hit = true;
            
            let feedback = '';
            let feedbackColor = 0xFFFFFF;
            let scoreValue = 0;

            if (timeDiff < HIT_WINDOWS.PERFECT) {
                feedback = 'PERFECT';
                feedbackColor = 0x00FFFF;
                scoreValue = SCORE_VALUES.PERFECT;
            } else if (timeDiff < HIT_WINDOWS.GOOD) {
                feedback = 'GOOD';
                feedbackColor = 0x90EE90;
                scoreValue = SCORE_VALUES.GOOD;
            } else {
                feedback = 'FAIR';
                feedbackColor = 0xFFD700;
                scoreValue = SCORE_VALUES.FAIR;
            }

            const targetY = GAME_HEIGHT - 100;
            createParticles(note.lane * LANE_WIDTH + LANE_WIDTH / 2, targetY, LANE_COLORS[note.lane]);
            showFeedback(feedback, note.lane, feedbackColor);
            
            incrementCombo();
            updateScore(scoreValue);
            
            removeNote(note);
        }

        function handleMiss(note) {
            note.hit = true;
            resetCombo();
            showFeedback('MISS', note.lane, 0xFF6347);

            const target = targets[note.lane];
            if (target) {
                const originalColor = LANE_COLORS[note.lane];
                target.tint = 0xFF0000;
                setTimeout(() => { if (target && !target.destroyed) target.tint = 0xFFFFFF; }, 200);
            }
            
            removeNote(note);
        }

        function removeNote(note) {
            const index = notesOnScreen.indexOf(note);
            if (index > -1) notesOnScreen.splice(index, 1);
            note.destroy();
        }
        
        function updateScore(points) {
            score += points * (combo > 1 ? Math.floor(combo / 10) + 1 : 1);
            scoreText.textContent = `Score: ${score}`;
        }

        function incrementCombo() {
            combo++;
            comboText.textContent = `Combo: ${combo}`;
            comboText.style.transform = 'scale(1.2)';
            setTimeout(() => { comboText.style.transform = 'scale(1)'; }, 100);
        }

        function resetCombo() {
            combo = 0;
            comboText.textContent = `Combo: ${combo}`;
        }

        window.onresize = function() {
            const newHeight = window.innerHeight * 0.95;
            pixiApp.renderer.resize(GAME_WIDTH, newHeight);
        };
    </script>
</body>
</html>
