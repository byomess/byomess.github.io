<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sistema Educacional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0D0D0D;
            color: #F9FAFB; /* text-gray-50 */
            overflow: hidden; /* Hide scrollbars */
        }
        .diagram-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            transform-origin: top left;
        }
        .node {
            position: absolute;
            background-color: #1A1A1A;
            border: 1px solid #4B5563; /* border-gray-600 */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 200px; /* Largura padrão */
        }
        .node-title {
            font-weight: 600;
            color: #F9FAFB; /* text-gray-50 */
            margin-bottom: 0.5rem;
        }
        .node-description {
            font-size: 0.875rem; /* text-sm */
            color: #D1D5DB; /* text-gray-300 */
            line-height: 1.25;
        }
        #diagram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* Cores específicas para cada grupo */
        .color-yellow { border-color: #F59E0B; } /* amber-500 */
        .color-blue { border-color: #3B82F6; } /* blue-500 */
        .color-green { border-color: #22C55E; } /* green-500 */
        .color-cyan { border-color: #06B6D4; } /* cyan-500 */
        
        .central-node {
            border-width: 2px;
            border-color: #A78BFA; /* violet-400 */
            background-color: #1A1A1A;
        }
    </style>
</head>
<body>

    <div id="diagram-container" class="diagram-container">
        <canvas id="diagram-canvas"></canvas>
    </div>

    <script>
        // --- CONFIGURAÇÃO DO DIAGRAMA ---
        // Para personalizar, edite os nós e conexões abaixo.
        // Posições são em porcentagem (x: 0-100, y: 0-100)
        const diagramData = {
            nodes: [
                // Marketplace group
                { id: 'vitrine', title: 'Vitrine Personalizada', description: 'Portfólio para criadores de conteúdo exibirem suas ofertas.', x: 5, y: 15, color: 'yellow' },
                { id: 'licenciamento', title: 'Gestão de Licenciamento', description: 'Modelos flexíveis de preço para diferentes tipos de vendas.', x: 5, y: 30, color: 'yellow' },
                { id: 'avaliacoes', title: 'Avaliações e Reviews', description: 'Sistema para feedback da comunidade sobre os cursos.', x: 5, y: 45, color: 'yellow' },
                { id: 'marketplace', title: 'Marketplace', description: 'Espaço para publicação e venda de cursos educacionais.', x: 25, y: 30, color: 'yellow' },

                // Classroom group
                { id: 'player', title: 'Player de Conteúdo', description: 'Interface unificada que apresenta todo o material didático.', x: 5, y: 60, color: 'blue' },
                { id: 'forum', title: 'Fórum de Dúvidas', description: 'Espaço colaborativo para interações entre alunos e professores.', x: 5, y: 75, color: 'blue' },
                { id: 'gamificacao', title: 'Gamificação', description: 'Sistema de engajamento com pontos, medalhas e rankings.', x: 5, y: 90, color: 'blue' },
                { id: 'classroom', title: 'Classroom', description: 'Ambiente virtual onde os alunos interagem e aprendem.', x: 25, y: 75, color: 'blue' },

                // Studio group
                { id: 'editor', title: 'Editor Visual', description: 'Interface intuitiva que permite arrastar e soltar elementos.', x: 80, y: 15, color: 'green' },
                { id: 'biblioteca', title: 'Biblioteca de Mídias', description: 'Gerenciamento centralizado de recursos educacionais e mídias.', x: 80, y: 30, color: 'green' },
                { id: 'templates', title: 'Templates de Conteúdo', description: 'Modelos pré-configurados para facilitar a criação de atividades.', x: 80, y: 45, color: 'green' },
                { id: 'studio', title: 'Studio', description: 'Ferramenta para criação de conteúdo interativo e dinâmico.', x: 60, y: 30, color: 'green' },

                // LXP group
                { id: 'organizacional', title: 'Estrutura Organizacional', description: 'Hierarquia visual para gerenciar cursos e turmas.', x: 80, y: 60, color: 'cyan' },
                { id: 'usuarios', title: 'Gestão de Usuários', description: 'Controle de acesso e permissões para diferentes perfis.', x: 80, y: 75, color: 'cyan' },
                { id: 'relatorios', title: 'Relatórios Avançados', description: 'Análises preditivas sobre desempenho e engajamento dos alunos.', x: 80, y: 90, color: 'cyan' },
                { id: 'lxp', title: 'LXP', description: 'Painel central para gerenciamento da estrutura institucional e experiência.', x: 60, y: 75, color: 'cyan' },

                // Central nodes
                { id: 'sistema', title: 'Sistema Educacional', description: 'Um ecossistema completo de apps com diversos módulos interativos.', x: 42.5, y: 30, isCentral: true, width: 250 },
                { id: 'chatbot', title: 'Chatbot', description: 'Produto independente de assistência virtual com IA de ponta.', x: 42.5, y: 60, isCentral: true, width: 250 },

                // Chatbot integrations
                { id: 'int-lms', title: 'Integração com LMS', description: 'Facilita a gestão e automatiza tarefas administrativas.', x: 20, y: 85, color: 'green' },
                { id: 'int-classroom', title: 'Integração com Classroom', description: 'Ajuda os alunos, respondendo dúvidas e oferecendo suporte.', x: 35, y: 90, color: 'green' },
                { id: 'int-studio', title: 'Integração com Studio', description: 'Auxilia na geração de conteúdo através de Inteligência Artificial.', x: 50, y: 90, color: 'green' },
                { id: 'int-marketplace', title: 'Integração com Marketplace', description: 'Oferece sugestões inteligentes de cursos e conteúdos aos usuários.', x: 65, y: 85, color: 'green' },
            ],
            connections: [
                // Marketplace
                { from: 'vitrine', to: 'marketplace', type: 'solid', color: 'yellow' },
                { from: 'licenciamento', to: 'marketplace', type: 'solid', color: 'yellow' },
                { from: 'avaliacoes', to: 'marketplace', type: 'solid', color: 'yellow' },
                { from: 'marketplace', to: 'sistema', type: 'solid', color: 'yellow' },

                // Classroom
                { from: 'player', to: 'classroom', type: 'solid', color: 'blue' },
                { from: 'forum', to: 'classroom', type: 'solid', color: 'blue' },
                { from: 'gamificacao', to: 'classroom', type: 'solid', color: 'blue' },
                { from: 'classroom', to: 'sistema', type: 'dashed', color: 'blue' },

                // Studio
                { from: 'editor', to: 'studio', type: 'solid', color: 'green' },
                { from: 'biblioteca', to: 'studio', type: 'solid', color: 'green' },
                { from: 'templates', to: 'studio', type: 'solid', color: 'green' },
                { from: 'studio', to: 'sistema', type: 'solid', color: 'green' },

                // LXP
                { from: 'organizacional', to: 'lxp', type: 'solid', color: 'cyan' },
                { from: 'usuarios', to: 'lxp', type: 'solid', color: 'cyan' },
                { from: 'relatorios', to: 'lxp', type: 'solid', color: 'cyan' },
                { from: 'lxp', to: 'sistema', type: 'dashed', color: 'cyan' },

                // Central
                { from: 'sistema', to: 'chatbot', type: 'solid', color: 'green' },

                // Chatbot Integrations
                { from: 'chatbot', to: 'int-lms', type: 'solid', color: 'green' },
                { from: 'chatbot', to: 'int-classroom', type: 'solid', color: 'green' },
                { from: 'chatbot', to: 'int-studio', type: 'solid', color: 'green' },
                { from: 'chatbot', to: 'int-marketplace', type: 'solid', color: 'green' },
            ]
        };

        // --- LÓGICA DO DIAGRAMA ---
        // (Geralmente não precisa mexer aqui)
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('diagram-container');
            const canvas = document.getElementById('diagram-canvas');
            const ctx = canvas.getContext('2d');

            const lineColors = {
                yellow: '#F59E0B',
                blue: '#3B82F6',
                green: '#22C55E',
                cyan: '#06B6D4',
            };

            let nodesById = {};
            let draggedNode = null;
            let offsetX, offsetY;

            function renderNodes() {
                container.innerHTML = ''; // Limpa nós antigos, mas mantém o canvas
                container.appendChild(canvas);

                diagramData.nodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.id = nodeData.id;
                    nodeEl.className = 'node';
                    if (nodeData.color) {
                        nodeEl.classList.add(`color-${nodeData.color}`);
                    }
                    if (nodeData.isCentral) {
                        nodeEl.classList.add('central-node');
                    }
                    
                    if (nodeData.width) {
                        nodeEl.style.width = `${nodeData.width}px`;
                    }

                    nodeEl.style.left = `${nodeData.x}%`;
                    nodeEl.style.top = `${nodeData.y}%`;
                    
                    const titleEl = document.createElement('div');
                    titleEl.className = 'node-title';
                    titleEl.textContent = nodeData.title;
                    
                    const descEl = document.createElement('div');
                    descEl.className = 'node-description';
                    descEl.textContent = nodeData.description;

                    nodeEl.appendChild(titleEl);
                    nodeEl.appendChild(descEl);
                    container.appendChild(nodeEl);
                    
                    nodesById[nodeData.id] = nodeEl;

                    nodeEl.addEventListener('mousedown', (e) => {
                        draggedNode = nodeEl;
                        container.style.cursor = 'grabbing';
                        nodeEl.style.cursor = 'grabbing';
                        const rect = nodeEl.getBoundingClientRect();
                        offsetX = e.clientX - rect.left;
                        offsetY = e.clientY - rect.top;
                    });
                });
            }

            function drawArrow(ctx, x, y, angle) {
                const size = 8;
                ctx.save();
                ctx.fillStyle = ctx.strokeStyle;
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, -size / 2);
                ctx.lineTo(-size, size / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            function drawConnections() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                diagramData.connections.forEach(conn => {
                    const fromNode = nodesById[conn.from];
                    const toNode = nodesById[conn.to];

                    if (!fromNode || !toNode) return;

                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const fromCenterX = (fromRect.left + fromRect.width / 2) - containerRect.left;
                    const fromCenterY = (fromRect.top + fromRect.height / 2) - containerRect.top;
                    const toCenterX = (toRect.left + toRect.width / 2) - containerRect.left;
                    const toCenterY = (toRect.top + toRect.height / 2) - containerRect.top;
                    
                    const dx = toCenterX - fromCenterX;
                    const dy = toCenterY - fromCenterY;

                    let startX, startY, endX, endY;
                    let cp1x, cp1y, cp2x, cp2y;

                    if (Math.abs(dx) > Math.abs(dy)) { // More horizontal
                        startY = fromCenterY;
                        endY = toCenterY;
                        if (dx > 0) { // right
                            startX = fromRect.right - containerRect.left;
                            endX = toRect.left - containerRect.left;
                        } else { // left
                            startX = fromRect.left - containerRect.left;
                            endX = toRect.right - containerRect.left;
                        }
                        cp1x = fromCenterX + dx * 0.5;
                        cp1y = fromCenterY;
                        cp2x = fromCenterX + dx * 0.5;
                        cp2y = toCenterY;
                    } else { // More vertical
                        startX = fromCenterX;
                        endX = toCenterX;
                        if (dy > 0) { // down
                            startY = fromRect.bottom - containerRect.top;
                            endY = toRect.top - containerRect.top;
                        } else { // up
                            startY = fromRect.top - containerRect.top;
                            endY = toRect.bottom - containerRect.top;
                        }
                        cp1x = fromCenterX;
                        cp1y = fromCenterY + dy * 0.5;
                        cp2x = toCenterX;
                        cp2y = fromCenterY + dy * 0.5;
                    }
                    
                    ctx.strokeStyle = lineColors[conn.color] || '#4B5563'; // Use color from connection or default
                    ctx.lineWidth = 2;

                    // Define o estilo da linha (sólida ou pontilhada)
                    if (conn.type === 'dashed') {
                        ctx.setLineDash([5, 5]);
                    } else {
                        ctx.setLineDash([]);
                    }

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();

                    if (conn.type === 'solid') {
                        // Arrows pointing to their destination for any connection involving the chatbot.
                        if (conn.from === 'chatbot' || conn.to === 'chatbot') {
                            const angle = Math.atan2(endY - cp2y, endX - cp2x);
                            drawArrow(ctx, endX, endY, angle);
                        }
                        // For other connections, the arrow should be at the 'from' node, pointing inwards.
                        else {
                            const angle = Math.atan2(startY - cp1y, startX - cp1x);
                            drawArrow(ctx, startX, startY, angle);
                        }
                    }
                });
            }
            
            function onMouseMove(e) {
                if (!draggedNode) return;
                const containerRect = container.getBoundingClientRect();
                
                let x = e.clientX - containerRect.left - offsetX;
                let y = e.clientY - containerRect.top - offsetY;

                let xPercent = (x / containerRect.width) * 100;
                let yPercent = (y / containerRect.height) * 100;

                xPercent = Math.max(0, Math.min(xPercent, 100 - (draggedNode.offsetWidth / containerRect.width * 100)));
                yPercent = Math.max(0, Math.min(yPercent, 100 - (draggedNode.offsetHeight / containerRect.height * 100)));

                draggedNode.style.left = `${xPercent}%`;
                draggedNode.style.top = `${yPercent}%`;

                const nodeData = diagramData.nodes.find(n => n.id === draggedNode.id);
                if(nodeData) {
                    nodeData.x = xPercent;
                    nodeData.y = yPercent;
                }

                drawConnections();
            }

            function onMouseUp() {
                if(draggedNode) {
                    draggedNode.style.cursor = 'grab';
                }
                draggedNode = null;
                container.style.cursor = 'default';
            }

            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);

            function initializeDiagram() {
                nodesById = {};
                renderNodes();
                setTimeout(drawConnections, 100);
            }

            window.addEventListener('resize', drawConnections);

            initializeDiagram();
        });
    </script>
</body>
</html>
