<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sistema Educacional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0D0D0D;
            color: #F9FAFB; /* text-gray-50 */
            overflow: hidden; /* Hide scrollbars */
            --grid-color: rgba(255, 255, 255, 0.07);
            background-image:
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        }
        .diagram-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            transform-origin: top left;
        }
        .node {
            position: absolute;
            background-color: #1A1A1A;
            border: 1px solid #4B5563; /* border-gray-600 */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 200px; /* Largura padrão */
        }
        .node-title {
            font-weight: 600;
            color: #F9FAFB; /* text-gray-50 */
            margin-bottom: 0.5rem;
        }
        .node-description {
            font-size: 0.875rem; /* text-sm */
            color: #D1D5DB; /* text-gray-300 */
            line-height: 1.25;
        }
        #diagram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* Cores específicas para cada grupo */
        .color-yellow { border-color: #F59E0B; } /* amber-500 */
        .color-blue { border-color: #3B82F6; } /* blue-500 */
        .color-green { border-color: #22C55E; } /* green-500 */
        .color-cyan { border-color: #06B6D4; } /* cyan-500 */
        .color-violet { border-color: #A78BFA; } /* violet-400 */
        
        .central-node {
            border-width: 2px;
            background-color: #1A1A1A;
        }
        .tooltip {
            position: absolute;
            background-color: #2D3748; /* gray-800 */
            color: white;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #4A5568; /* gray-600 */
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            pointer-events: all;
        }
        .tooltip.hidden {
            display: none;
        }
        .tooltip-section {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .tooltip-section + .tooltip-section {
            border-left: 1px solid #4A5568; /* gray-600 */
            padding-left: 8px;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .color-swatch:hover {
            border-color: white;
        }
        .tooltip-button {
            background: none;
            border: 1px solid #4A5568;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        .tooltip-button:hover {
            background-color: #4A5568;
        }
        .tooltip-button.active {
            background-color: #3B82F6; /* blue-500 */
            border-color: #3B82F6;
        }
        .tooltip-button.delete {
            background-color: #E53E3E; /* red-600 */
        }
        .tooltip-button.delete:hover {
            background-color: #C53030; /* red-700 */
        }
        .context-menu {
            position: absolute;
            background-color: #2D3748; /* gray-800 */
            color: white;
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #4A5568; /* gray-600 */
            z-index: 101;
            pointer-events: all;
        }
        .context-menu.hidden {
            display: none;
        }
        .context-menu-item {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
        }
        .context-menu-item:hover {
            background-color: #4A5568;
        }
        .save-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #3B82F6; /* blue-500 */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 102;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .save-button:hover {
            background-color: #2563EB; /* blue-600 */
        }
        .save-button.saving {
            background-color: #22C55E; /* green-500 */
        }
    </style>
</head>
<body>

    <button id="save-button" class="save-button">Salvar</button>
    <div id="diagram-container" class="diagram-container">
        <canvas id="diagram-canvas"></canvas>
    </div>
    <div id="tooltip" class="tooltip hidden"></div>
    <div id="context-menu" class="context-menu hidden"></div>

    <script>
        // --- CONFIGURAÇÃO DO DIAGRAMA ---
        // Para personalizar, edite os nós e conexões abaixo.
        // Posições são em porcentagem (x: 0-100, y: 0-100)
        const diagramData = {
            nodes: [
                // Marketplace group
                { id: 'vitrine', title: 'Vitrine Personalizada', description: 'Portfólio para criadores de conteúdo exibirem suas ofertas.', x: 5, y: 15, color: 'yellow' },
                { id: 'licenciamento', title: 'Gestão de Licenciamento', description: 'Modelos flexíveis de preço para diferentes tipos de vendas.', x: 5, y: 30, color: 'yellow' },
                { id: 'avaliacoes', title: 'Avaliações e Reviews', description: 'Sistema para feedback da comunidade sobre os cursos.', x: 5, y: 45, color: 'yellow' },
                { id: 'marketplace', title: 'Marketplace', description: 'Espaço para publicação e venda de cursos educacionais.', x: 25, y: 30, color: 'yellow' },

                // Classroom group
                { id: 'player', title: 'Player de Conteúdo', description: 'Interface unificada que apresenta todo o material didático.', x: 5, y: 60, color: 'blue' },
                { id: 'forum', title: 'Fórum de Dúvidas', description: 'Espaço colaborativo para interações entre alunos e professores.', x: 5, y: 75, color: 'blue' },
                { id: 'gamificacao', title: 'Gamificação', description: 'Sistema de engajamento com pontos, medalhas e rankings.', x: 5, y: 90, color: 'blue' },
                { id: 'classroom', title: 'Classroom', description: 'Ambiente virtual onde os alunos interagem e aprendem.', x: 25, y: 75, color: 'blue' },

                // Studio group
                { id: 'editor', title: 'Editor Visual', description: 'Interface intuitiva que permite arrastar e soltar elementos.', x: 80, y: 15, color: 'green' },
                { id: 'biblioteca', title: 'Biblioteca de Mídias', description: 'Gerenciamento centralizado de recursos educacionais e mídias.', x: 80, y: 30, color: 'green' },
                { id: 'templates', title: 'Templates de Conteúdo', description: 'Modelos pré-configurados para facilitar a criação de atividades.', x: 80, y: 45, color: 'green' },
                { id: 'studio', title: 'Studio', description: 'Ferramenta para criação de conteúdo interativo e dinâmico.', x: 60, y: 30, color: 'green' },

                // LXP group
                { id: 'organizacional', title: 'Estrutura Organizacional', description: 'Hierarquia visual para gerenciar cursos e turmas.', x: 80, y: 60, color: 'cyan' },
                { id: 'usuarios', title: 'Gestão de Usuários', description: 'Controle de acesso e permissões para diferentes perfis.', x: 80, y: 75, color: 'cyan' },
                { id: 'relatorios', title: 'Relatórios Avançados', description: 'Análises preditivas sobre desempenho e engajamento dos alunos.', x: 80, y: 90, color: 'cyan' },
                { id: 'lxp', title: 'LXP', description: 'Painel central para gerenciamento da estrutura institucional e experiência.', x: 60, y: 75, color: 'cyan' },

                // Central nodes
                { id: 'sistema', title: 'Sistema Educacional', description: 'Um ecossistema completo de apps com diversos módulos interativos.', x: 42.5, y: 30, isCentral: true, width: 250, color: 'violet' },
                { id: 'chatbot', title: 'Chatbot', description: 'Produto independente de assistência virtual com IA de ponta.', x: 42.5, y: 60, isCentral: true, width: 250, color: 'violet' },

                // Chatbot integrations
                { id: 'int-lms', title: 'Integração com LMS', description: 'Facilita a gestão e automatiza tarefas administrativas.', x: 20, y: 85, color: 'violet' },
                { id: 'int-classroom', title: 'Integração com Classroom', description: 'Ajuda os alunos, respondendo dúvidas e oferecendo suporte.', x: 35, y: 90, color: 'violet' },
                { id: 'int-studio', title: 'Integração com Studio', description: 'Auxilia na geração de conteúdo através de Inteligência Artificial.', x: 50, y: 90, color: 'violet' },
                { id: 'int-marketplace', title: 'Integração com Marketplace', description: 'Oferece sugestões inteligentes de cursos e conteúdos aos usuários.', x: 65, y: 85, color: 'violet' },
            ],
            connections: [
                // Marketplace
                { from: 'vitrine', to: 'marketplace', type: 'solid', color: 'yellow', arrow: 'from' },
                { from: 'licenciamento', to: 'marketplace', type: 'solid', color: 'yellow', arrow: 'from' },
                { from: 'avaliacoes', to: 'marketplace', type: 'solid', color: 'yellow', arrow: 'from' },
                { from: 'marketplace', to: 'sistema', type: 'solid', color: 'yellow', arrow: 'from' },

                // Classroom
                { from: 'player', to: 'classroom', type: 'solid', color: 'blue', arrow: 'from' },
                { from: 'forum', to: 'classroom', type: 'solid', color: 'blue', arrow: 'from' },
                { from: 'gamificacao', to: 'classroom', type: 'solid', color: 'blue', arrow: 'from' },
                { from: 'classroom', to: 'sistema', type: 'dashed', color: 'blue' },

                // Studio
                { from: 'editor', to: 'studio', type: 'solid', color: 'green', arrow: 'from' },
                { from: 'biblioteca', to: 'studio', type: 'solid', color: 'green', arrow: 'from' },
                { from: 'templates', to: 'studio', type: 'solid', color: 'green', arrow: 'from' },
                { from: 'studio', to: 'sistema', type: 'solid', color: 'green', arrow: 'from' },

                // LXP
                { from: 'organizacional', to: 'lxp', type: 'solid', color: 'cyan', arrow: 'from' },
                { from: 'usuarios', to: 'lxp', type: 'solid', color: 'cyan', arrow: 'from' },
                { from: 'relatorios', to: 'lxp', type: 'solid', color: 'cyan', arrow: 'from' },
                { from: 'lxp', to: 'sistema', type: 'dashed', color: 'cyan' },

                // Central
                { from: 'sistema', to: 'chatbot', type: 'solid', color: 'green', arrow: 'to' },

                // Chatbot Integrations
                { from: 'chatbot', to: 'int-lms', type: 'solid', color: 'violet', arrow: 'to' },
                { from: 'chatbot', to: 'int-classroom', type: 'solid', color: 'violet', arrow: 'to' },
                { from: 'chatbot', to: 'int-studio', type: 'solid', color: 'violet', arrow: 'to' },
                { from: 'chatbot', to: 'int-marketplace', type: 'solid', color: 'violet', arrow: 'to' },
            ]
        };

        // --- LÓGICA DO DIAGRAMA ---
        // (Geralmente não precisa mexer aqui)
        document.addEventListener('DOMContentLoaded', () => {
            let db;
            const DB_NAME = 'MindmapDB';
            const STORE_NAME = 'diagramState';

            const container = document.getElementById('diagram-container');
            const canvas = document.getElementById('diagram-canvas');
            const ctx = canvas.getContext('2d');

            const lineColors = {
                yellow: '#F59E0B',
                blue: '#3B82F6',
                green: '#22C55E',
                cyan: '#06B6D4',
                violet: '#A78BFA',
            };

            const tooltip = document.getElementById('tooltip');
            const contextMenu = document.getElementById('context-menu');
            let nodesById = {};
            let draggedNode = null;
            let offsetX, offsetY;
            let isDragging = false;

            let scale = 1, panX = 0, panY = 0;
            let isPanning = false, panStart = { x: 0, y: 0 };
            let selectedItem = null;
            let isConnecting = false;
            let connectionStartNodeId = null;

            function initDB(callback) {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = (event) => console.error("Database error:", event.target.error);
                request.onsuccess = (event) => {
                    db = event.target.result;
                    if (callback) callback();
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
            }
            
            function saveDiagramState() {
                if (!db) return;
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.put({ id: 'current', data: diagramData });
                
                request.onsuccess = () => {
                    const saveButton = document.getElementById('save-button');
                    saveButton.textContent = 'Salvo!';
                    saveButton.classList.add('saving');
                    setTimeout(() => {
                        saveButton.textContent = 'Salvar';
                        saveButton.classList.remove('saving');
                    }, 1500);
                };
                request.onerror = (event) => console.error("Error saving state:", event.target.error);
            }

            function loadDiagramState(callback) {
                if (!db) return;
                const transaction = db.transaction([STORE_NAME]);
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.get('current');

                request.onsuccess = (event) => {
                    if (request.result) {
                        // A simple merge to keep defaults for new properties
                        Object.assign(diagramData, request.result.data);
                    }
                    if (callback) callback();
                };
                request.onerror = (event) => {
                    console.error("Error loading state:", event.target.error);
                    if (callback) callback(); // still call callback on error
                };
            }

            function updateTransform() {
                container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                const gridSize = 20;
                document.body.style.backgroundSize = `${gridSize * scale}px ${gridSize * scale}px`;
                document.body.style.backgroundPosition = `${panX}px ${panY}px`;
            }

            function renderNodes() {
                container.innerHTML = ''; // Limpa nós antigos, mas mantém o canvas
                container.appendChild(canvas);

                diagramData.nodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.id = nodeData.id;
                    nodeEl.className = 'node';
                    if (nodeData.color) {
                        nodeEl.classList.add(`color-${nodeData.color}`);
                    }
                    if (nodeData.isCentral) {
                        nodeEl.classList.add('central-node');
                    }
                    
                    if (nodeData.width) {
                        nodeEl.style.width = `${nodeData.width}px`;
                    }

                    nodeEl.style.left = `${nodeData.x}%`;
                    nodeEl.style.top = `${nodeData.y}%`;
                    
                    const titleEl = document.createElement('div');
                    titleEl.className = 'node-title';
                    titleEl.innerText = nodeData.title;
                    titleEl.contentEditable = true;
                    
                    const descEl = document.createElement('div');
                    descEl.className = 'node-description';
                    descEl.innerText = nodeData.description;
                    descEl.contentEditable = true;

                    // Prevent dragging when editing text
                    titleEl.addEventListener('mousedown', e => e.stopPropagation());
                    descEl.addEventListener('mousedown', e => e.stopPropagation());

                    // Save changes on blur
                    titleEl.addEventListener('blur', () => {
                        nodeData.title = titleEl.innerText;
                    });
                    descEl.addEventListener('blur', () => {
                        nodeData.description = descEl.innerText;
                    });

                    nodeEl.appendChild(titleEl);
                    nodeEl.appendChild(descEl);
                    container.appendChild(nodeEl);
                    
                    nodesById[nodeData.id] = nodeEl;

                    nodeEl.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return; // Only main button drags
                        isDragging = false;
                        draggedNode = nodeEl;
                        container.style.cursor = 'grabbing';
                        nodeEl.style.cursor = 'grabbing';
                        const rect = nodeEl.getBoundingClientRect();
                        offsetX = e.clientX - rect.left;
                        offsetY = e.clientY - rect.top;
                        e.stopPropagation();
                    });
                });
            }

            function drawArrow(ctx, x, y, angle) {
                const size = 8;
                ctx.save();
                ctx.fillStyle = ctx.strokeStyle;
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, -size / 2);
                ctx.lineTo(-size, size / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            function drawConnections() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                diagramData.connections.forEach(conn => {
                    const fromNode = nodesById[conn.from];
                    const toNode = nodesById[conn.to];

                    if (!fromNode || !toNode) return;

                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const fromCenterX = (fromRect.left + fromRect.width / 2) - containerRect.left;
                    const fromCenterY = (fromRect.top + fromRect.height / 2) - containerRect.top;
                    const toCenterX = (toRect.left + toRect.width / 2) - containerRect.left;
                    const toCenterY = (toRect.top + toRect.height / 2) - containerRect.top;
                    
                    const dx = toCenterX - fromCenterX;
                    const dy = toCenterY - fromCenterY;

                    let startX, startY, endX, endY;
                    let cp1x, cp1y, cp2x, cp2y;

                    if (Math.abs(dx) > Math.abs(dy)) { // More horizontal
                        startY = fromCenterY;
                        endY = toCenterY;
                        if (dx > 0) { // right
                            startX = fromRect.right - containerRect.left;
                            endX = toRect.left - containerRect.left;
                        } else { // left
                            startX = fromRect.left - containerRect.left;
                            endX = toRect.right - containerRect.left;
                        }
                        cp1x = fromCenterX + dx * 0.5;
                        cp1y = fromCenterY;
                        cp2x = fromCenterX + dx * 0.5;
                        cp2y = toCenterY;
                    } else { // More vertical
                        startX = fromCenterX;
                        endX = toCenterX;
                        if (dy > 0) { // down
                            startY = fromRect.bottom - containerRect.top;
                            endY = toRect.top - containerRect.top;
                        } else { // up
                            startY = fromRect.top - containerRect.top;
                            endY = toRect.bottom - containerRect.top;
                        }
                        cp1x = fromCenterX;
                        cp1y = fromCenterY + dy * 0.5;
                        cp2x = toCenterX;
                        cp2y = fromCenterY + dy * 0.5;
                    }
                    
                    ctx.strokeStyle = lineColors[conn.color] || '#4B5563'; // Use color from connection or default
                    ctx.lineWidth = 2;

                    // Define o estilo da linha (sólida ou pontilhada)
                    if (conn.type === 'dashed') {
                        ctx.setLineDash([5, 5]);
                    } else {
                        ctx.setLineDash([]);
                    }

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();
                    conn._renderData = { startX, startY, cp1x, cp1y, cp2x, cp2y, endX, endY }; // Cache for hit detection

                    if (conn.type === 'solid' && conn.arrow && conn.arrow !== 'none') {
                        const toAngle = Math.atan2(endY - cp2y, endX - cp2x);
                        const fromAngle = Math.atan2(startY - cp1y, startX - cp1x);

                        if (conn.arrow === 'to' || conn.arrow === 'both') {
                            drawArrow(ctx, endX, endY, toAngle);
                        }
                        if (conn.arrow === 'from' || conn.arrow === 'both') {
                            drawArrow(ctx, startX, startY, fromAngle);
                        }
                    }
                });
            }
            
            function onMouseMove(e) {
                if (isPanning) {
                    panX = e.clientX - panStart.x;
                    panY = e.clientY - panStart.y;
                    updateTransform();
                    drawConnections();
                    return;
                }

                if (!draggedNode) return;
                isDragging = true;

                const parentRect = container.parentElement.getBoundingClientRect();
                
                const mouseX = e.clientX - parentRect.left;
                const mouseY = e.clientY - parentRect.top;

                let x = (mouseX - panX - offsetX) / scale;
                let y = (mouseY - panY - offsetY) / scale;

                let xPercent = (x / container.offsetWidth) * 100;
                let yPercent = (y / container.offsetHeight) * 100;

                draggedNode.style.left = `${xPercent}%`;
                draggedNode.style.top = `${yPercent}%`;

                const nodeData = diagramData.nodes.find(n => n.id === draggedNode.id);
                if(nodeData) {
                    nodeData.x = xPercent;
                    nodeData.y = yPercent;
                }

                drawConnections();
            }

            function onMouseUp(e) {
                const clickedNodeData = draggedNode ? diagramData.nodes.find(n => n.id === draggedNode.id) : null;
                
                if (isConnecting && clickedNodeData && connectionStartNodeId !== clickedNodeData.id) {
                    // Finalize connection
                    const newConnection = {
                        from: connectionStartNodeId,
                        to: clickedNodeData.id,
                        type: 'solid',
                        color: 'green',
                        arrow: 'to'
                    };
                    diagramData.connections.push(newConnection);
                    drawConnections();
                    
                    isConnecting = false;
                    connectionStartNodeId = null;
                    container.style.cursor = 'default';

                } else if (draggedNode && !isDragging) { // This is a click on a node
                    showTooltip(e, clickedNodeData);
                }

                isPanning = false;
                isDragging = false;

                if(draggedNode) {
                    draggedNode.style.cursor = 'grab';
                }
                draggedNode = null;
                container.style.cursor = 'default';
            }

            function hideTooltip() {
                tooltip.classList.add('hidden');
                tooltip.innerHTML = '';
                selectedItem = null;
            }

            function hideContextMenu() {
                contextMenu.classList.add('hidden');
            }

            function showTooltip(e, item) {
                hideTooltip();
                selectedItem = item;
                tooltip.classList.remove('hidden');

                const availableColors = Object.keys(lineColors);

                if (item.hasOwnProperty('title')) { // Is a node
                    populateNodeTooltip(item, availableColors);
                    const nodeEl = nodesById[item.id];
                    const nodeRect = nodeEl.getBoundingClientRect();
                    tooltip.style.left = `${nodeRect.left}px`;
                    tooltip.style.top = `${nodeRect.bottom + 10}px`;
                } else { // Is a connection
                    populateConnectionTooltip(item, availableColors);
                    tooltip.style.left = `${e.clientX}px`;
                    tooltip.style.top = `${e.clientY}px`;
                }
            }

            function populateNodeTooltip(node, colors) {
                const colorSection = document.createElement('div');
                colorSection.className = 'tooltip-section';
                colors.forEach(colorName => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = lineColors[colorName];
                    swatch.addEventListener('click', () => {
                        const oldColor = node.color;
                        const nodeEl = nodesById[node.id];
                        if (oldColor) nodeEl.classList.remove(`color-${oldColor}`);
                        nodeEl.classList.add(`color-${colorName}`);
                        node.color = colorName;
                        hideTooltip();
                    });
                    colorSection.appendChild(swatch);
                });
                tooltip.appendChild(colorSection);

                // Actions Section
                const actionsSection = document.createElement('div');
                actionsSection.className = 'tooltip-section';

                // Connect Button
                const connectBtn = document.createElement('button');
                connectBtn.className = 'tooltip-button';
                connectBtn.textContent = 'Conectar';
                connectBtn.addEventListener('click', () => {
                    isConnecting = true;
                    connectionStartNodeId = node.id;
                    container.style.cursor = 'crosshair';
                    hideTooltip();
                });
                actionsSection.appendChild(connectBtn);

                // Delete Button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'tooltip-button delete';
                deleteBtn.textContent = 'Deletar';
                deleteBtn.addEventListener('click', () => {
                    // Remove node
                    diagramData.nodes = diagramData.nodes.filter(n => n.id !== node.id);
                    // Remove associated connections
                    diagramData.connections = diagramData.connections.filter(c => c.from !== node.id && c.to !== node.id);
                    hideTooltip();
                    initializeDiagram();
                });
                actionsSection.appendChild(deleteBtn);
                
                tooltip.appendChild(actionsSection);
            }

            function populateConnectionTooltip(conn, colors) {
                // Color section
                const colorSection = document.createElement('div');
                colorSection.className = 'tooltip-section';
                colors.forEach(colorName => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = lineColors[colorName];
                    swatch.addEventListener('click', () => {
                        conn.color = colorName;
                        drawConnections();
                        hideTooltip();
                    });
                    colorSection.appendChild(swatch);
                });
                tooltip.appendChild(colorSection);

                // Style section
                const styleSection = document.createElement('div');
                styleSection.className = 'tooltip-section';
                ['solid', 'dashed'].forEach(style => {
                    const btn = document.createElement('button');
                    btn.className = 'tooltip-button';
                    if (conn.type === style) btn.classList.add('active');
                    btn.textContent = style.charAt(0).toUpperCase() + style.slice(1);
                    btn.addEventListener('click', () => {
                        conn.type = style;
                        drawConnections();
                        // Re-render tooltip to update active state
                        const tempEvent = { clientX: parseInt(tooltip.style.left), clientY: parseInt(tooltip.style.top) };
                        showTooltip(tempEvent, conn);
                    });
                    styleSection.appendChild(btn);
                });
                tooltip.appendChild(styleSection);

                // Arrow section
                const arrowSection = document.createElement('div');
                arrowSection.className = 'tooltip-section';
                ['none', 'from', 'to', 'both'].forEach(dir => {
                    const btn = document.createElement('button');
                    btn.className = 'tooltip-button';
                    if ((conn.arrow || 'none') === dir) btn.classList.add('active');
                    btn.textContent = dir.charAt(0).toUpperCase() + dir.slice(1);
                    btn.addEventListener('click', () => {
                        conn.arrow = dir;
                        drawConnections();
                        const tempEvent = { clientX: parseInt(tooltip.style.left), clientY: parseInt(tooltip.style.top) };
                        showTooltip(tempEvent, conn);
                    });
                    arrowSection.appendChild(btn);
                });
                tooltip.appendChild(arrowSection);

                // Delete Button Section
                const deleteSection = document.createElement('div');
                deleteSection.className = 'tooltip-section';
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'tooltip-button delete';
                deleteBtn.textContent = 'Deletar';
                deleteBtn.addEventListener('click', () => {
                    diagramData.connections = diagramData.connections.filter(c => c !== conn);
                    hideTooltip();
                    drawConnections();
                });
                deleteSection.appendChild(deleteBtn);
                tooltip.appendChild(deleteSection);
            }

            function createNodeAtPosition(clientX, clientY) {
                const parentRect = container.parentElement.getBoundingClientRect();
                const mouseX = clientX - parentRect.left;
                const mouseY = clientY - parentRect.top;

                const x = (mouseX - panX) / scale;
                const y = (mouseY - panY) / scale;

                const xPercent = (x / container.offsetWidth) * 100;
                const yPercent = (y / container.offsetHeight) * 100;

                const newNode = {
                    id: `node_${Date.now()}`,
                    title: 'Novo Card',
                    description: 'Clique para editar o texto.',
                    x: xPercent,
                    y: yPercent,
                    color: 'green'
                };

                diagramData.nodes.push(newNode);
                initializeDiagram();
            }
            
            function getCanvasPoint(event) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }

            // Function to check distance from a point to a line segment
            function distToSegmentSquared(p, v, w) {
                const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
                if (l2 == 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return (p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2;
            }

            function isPointOnBezier(p, start, cp1, cp2, end, threshold) {
                const samples = 20;
                let prevPoint = start;
                for (let i = 1; i <= samples; i++) {
                    const t = i / samples;
                    const invT = 1 - t;
                    const x = invT**3 * start.x + 3 * invT**2 * t * cp1.x + 3 * invT * t**2 * cp2.x + t**3 * end.x;
                    const y = invT**3 * start.y + 3 * invT**2 * t * cp1.y + 3 * invT * t**2 * cp2.y + t**3 * end.y;
                    const currentPoint = {x, y};
                    if (distToSegmentSquared(p, prevPoint, currentPoint) < threshold**2) {
                        return true;
                    }
                    prevPoint = currentPoint;
                }
                return false;
            }

            container.addEventListener('mousedown', (e) => {
                // Background click
                if (e.target === container || e.target === canvas) {
                    hideTooltip();
                    hideContextMenu();
                    if (isConnecting) {
                        isConnecting = false;
                        connectionStartNodeId = null;
                        container.style.cursor = 'default';
                    }
                }
                // Pan with middle mouse button, only if not dragging a node.
                if (e.button === 1 && !draggedNode) {
                    isPanning = true;
                    panStart.x = e.clientX - panX;
                    panStart.y = e.clientY - panY;
                    container.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            canvas.addEventListener('click', (e) => {
                const point = getCanvasPoint(e);
                const threshold = 10; // Click tolerance in pixels

                let clickedConnection = null;
                // Iterate backwards so we click the top-most connection
                for (const conn of [...diagramData.connections].reverse()) {
                    if (conn._renderData) {
                        const rd = conn._renderData;
                        const start = {x: rd.startX, y: rd.startY};
                        const cp1 = {x: rd.cp1x, y: rd.cp1y};
                        const cp2 = {x: rd.cp2x, y: rd.cp2y};
                        const end = {x: rd.endX, y: rd.endY};
                        if (isPointOnBezier(point, start, cp1, cp2, end, threshold)) {
                            clickedConnection = conn;
                            break;
                        }
                    }
                }

                if (clickedConnection) {
                    showTooltip(e, clickedConnection);
                }
            });

            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const oldScale = scale;
                const zoomFactor = 1.1;

                if (e.deltaY < 0) {
                    scale *= zoomFactor;
                } else {
                    scale /= zoomFactor;
                }
                scale = Math.max(0.2, Math.min(scale, 5));

                panX = mouseX - (mouseX - panX) * (scale / oldScale);
                panY = mouseY - (mouseY - panY) * (scale / oldScale);
                
                updateTransform();
                drawConnections();
            }, { passive: false });

            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (draggedNode || isPanning || e.target.closest('.node')) return;

                hideTooltip();
                contextMenu.classList.remove('hidden');
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;

                contextMenu.innerHTML = ''; // Clear old items

                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                menuItem.textContent = 'Criar novo card';
                menuItem.onclick = () => {
                    createNodeAtPosition(e.clientX, e.clientY);
                    hideContextMenu();
                };
                contextMenu.appendChild(menuItem);
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (isConnecting) {
                        isConnecting = false;
                        connectionStartNodeId = null;
                        container.style.cursor = 'default';
                    }
                    // Check if an editable element inside a node has focus
                    if (document.activeElement && document.activeElement.isContentEditable && document.activeElement.closest('.node')) {
                        document.activeElement.blur();
                    }
                }
            });

            function initializeDiagram() {
                nodesById = {};
                updateTransform();
                renderNodes();
                setTimeout(drawConnections, 100);
            }

            window.addEventListener('resize', drawConnections);

            initDB(() => {
                loadDiagramState(() => {
                    initializeDiagram();
                });
            });

            document.getElementById('save-button').addEventListener('click', saveDiagramState);
        });
    </script>
</body>
</html>
