<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sistema Educacional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0D0D0D;
            color: #F9FAFB; /* text-gray-50 */
            overflow: hidden; /* Hide scrollbars */
            --grid-color: rgba(255, 255, 255, 0.07);
            background-image:
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        }
        .diagram-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            transform-origin: top left;
        }
        .node {
            position: absolute;
            background-color: #1A1A1A;
            border: 1px solid #4B5563; /* border-gray-600 */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 200px; /* Largura padrão */
        }
        .node.resizing {
            transition: none;
        }
        .node-title {
            font-weight: 600;
            color: #F9FAFB; /* text-gray-50 */
            margin-bottom: 0.5rem;
            user-select: none;
        }
        .node-description {
            font-size: 0.875rem; /* text-sm */
            color: #D1D5DB; /* text-gray-300 */
            line-height: 1.25;
            user-select: none;
        }
        #diagram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* Cores específicas para cada grupo */
        .color-yellow { border-color: #F59E0B; } /* amber-500 */
        .color-blue { border-color: #3B82F6; } /* blue-500 */
        .color-green { border-color: #22C55E; } /* green-500 */
        .color-cyan { border-color: #06B6D4; } /* cyan-500 */
        .color-violet { border-color: #A78BFA; } /* violet-400 */
        
        .central-node {
            border-width: 2px;
            background-color: #1A1A1A;
        }
        .tooltip {
            position: absolute;
            background-color: #2D3748; /* gray-800 */
            color: white;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #4A5568; /* gray-600 */
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            pointer-events: all;
        }
        .tooltip.hidden {
            display: none;
        }
        .tooltip-section {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .tooltip-section + .tooltip-section {
            border-left: 1px solid #4A5568; /* gray-600 */
            padding-left: 8px;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .color-swatch:hover {
            border-color: white;
        }
        .tooltip-button {
            background: none;
            border: 1px solid #4A5568;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        .tooltip-button:hover {
            background-color: #4A5568;
        }
        .tooltip-button.active {
            background-color: #3B82F6; /* blue-500 */
            border-color: #3B82F6;
        }
        .tooltip-button.delete {
            background-color: #E53E3E; /* red-600 */
        }
        .tooltip-button.delete:hover {
            background-color: #C53030; /* red-700 */
        }
        .context-menu {
            position: absolute;
            background-color: #2D3748; /* gray-800 */
            color: white;
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #4A5568; /* gray-600 */
            z-index: 101;
            pointer-events: all;
        }
        .context-menu.hidden {
            display: none;
        }
        .context-menu-item {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
        }
        .context-menu-item:hover {
            background-color: #4A5568;
        }
        .save-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #3B82F6; /* blue-500 */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 102;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .save-button:hover {
            background-color: #2563EB; /* blue-600 */
        }
        .save-button.saving {
            background-color: #22C55E; /* green-500 */
        }
    </style>
</head>
<body>

    <button id="save-button" class="save-button">Salvar</button>
    <div id="diagram-container" class="diagram-container">
        <canvas id="diagram-canvas"></canvas>
    </div>
    <div id="tooltip" class="tooltip hidden"></div>
    <div id="context-menu" class="context-menu hidden"></div>

    <script>
        // --- CONFIGURAÇÃO DO DIAGRAMA ---
        // Para personalizar, edite os nós e conexões abaixo.
        // Posições são em porcentagem (x: 0-100, y: 0-100)
        const diagramData = {
            nodes: [
                // Marketplace group
                { id: 'vitrine', title: 'Vitrine Personalizada', description: 'Portfólio para criadores de conteúdo exibirem suas ofertas.', x: 5, y: 15, color: 'yellow' },
                { id: 'licenciamento', title: 'Gestão de Licenciamento', description: 'Modelos flexíveis de preço para diferentes tipos de vendas.', x: 5, y: 30, color: 'yellow' },
                { id: 'avaliacoes', title: 'Avaliações e Reviews', description: 'Sistema para feedback da comunidade sobre os cursos.', x: 5, y: 45, color: 'yellow' },
                { id: 'marketplace', title: 'Marketplace', description: 'Espaço para publicação e venda de cursos educacionais.', x: 25, y: 30, color: 'yellow' },

                // Classroom group
                { id: 'player', title: 'Player de Conteúdo', description: 'Interface unificada que apresenta todo o material didático.', x: 5, y: 60, color: 'blue' },
                { id: 'forum', title: 'Fórum de Dúvidas', description: 'Espaço colaborativo para interações entre alunos e professores.', x: 5, y: 75, color: 'blue' },
                { id: 'gamificacao', title: 'Gamificação', description: 'Sistema de engajamento com pontos, medalhas e rankings.', x: 5, y: 90, color: 'blue' },
                { id: 'classroom', title: 'Classroom', description: 'Ambiente virtual onde os alunos interagem e aprendem.', x: 25, y: 75, color: 'blue' },

                // Studio group
                { id: 'editor', title: 'Editor Visual', description: 'Interface intuitiva que permite arrastar e soltar elementos.', x: 80, y: 15, color: 'green' },
                { id: 'biblioteca', title: 'Biblioteca de Mídias', description: 'Gerenciamento centralizado de recursos educacionais e mídias.', x: 80, y: 30, color: 'green' },
                { id: 'templates', title: 'Templates de Conteúdo', description: 'Modelos pré-configurados para facilitar a criação de atividades.', x: 80, y: 45, color: 'green' },
                { id: 'studio', title: 'Studio', description: 'Ferramenta para criação de conteúdo interativo e dinâmico.', x: 60, y: 30, color: 'green' },

                // LXP group
                { id: 'organizacional', title: 'Estrutura Organizacional', description: 'Hierarquia visual para gerenciar cursos e turmas.', x: 80, y: 60, color: 'cyan' },
                { id: 'usuarios', title: 'Gestão de Usuários', description: 'Controle de acesso e permissões para diferentes perfis.', x: 80, y: 75, color: 'cyan' },
                { id: 'relatorios', title: 'Relatórios Avançados', description: 'Análises preditivas sobre desempenho e engajamento dos alunos.', x: 80, y: 90, color: 'cyan' },
                { id: 'lxp', title: 'LXP', description: 'Painel central para gerenciamento da estrutura institucional e experiência.', x: 60, y: 75, color: 'cyan' },

                // Central nodes
                { id: 'sistema', title: 'Sistema Educacional', description: 'Um ecossistema completo de apps com diversos módulos interativos.', x: 42.5, y: 30, isCentral: true, width: 250, color: 'violet' },
                { id: 'chatbot', title: 'Chatbot', description: 'Produto independente de assistência virtual com IA de ponta.', x: 42.5, y: 60, isCentral: true, width: 250, color: 'violet' },

                // Chatbot integrations
                { id: 'int-lms', title: 'Integração com LMS', description: 'Facilita a gestão e automatiza tarefas administrativas.', x: 20, y: 85, color: 'violet' },
                { id: 'int-classroom', title: 'Integração com Classroom', description: 'Ajuda os alunos, respondendo dúvidas e oferecendo suporte.', x: 35, y: 90, color: 'violet' },
                { id: 'int-studio', title: 'Integração com Studio', description: 'Auxilia na geração de conteúdo através de Inteligência Artificial.', x: 50, y: 90, color: 'violet' },
                { id: 'int-marketplace', title: 'Integração com Marketplace', description: 'Oferece sugestões inteligentes de cursos e conteúdos aos usuários.', x: 65, y: 85, color: 'violet' },
            ],
            connections: [
                // Marketplace
                { from: 'vitrine', to: 'marketplace', type: 'solid', color: 'yellow', arrow: 'from' },
                { from: 'licenciamento', to: 'marketplace', type: 'solid', color: 'yellow', arrow: 'from' },
                { from: 'avaliacoes', to: 'marketplace', type: 'solid', color: 'yellow', arrow: 'from' },
                { from: 'marketplace', to: 'sistema', type: 'solid', color: 'yellow', arrow: 'from' },

                // Classroom
                { from: 'player', to: 'classroom', type: 'solid', color: 'blue', arrow: 'from' },
                { from: 'forum', to: 'classroom', type: 'solid', color: 'blue', arrow: 'from' },
                { from: 'gamificacao', to: 'classroom', type: 'solid', color: 'blue', arrow: 'from' },
                { from: 'classroom', to: 'sistema', type: 'dashed', color: 'blue' },

                // Studio
                { from: 'editor', to: 'studio', type: 'solid', color: 'green', arrow: 'from' },
                { from: 'biblioteca', to: 'studio', type: 'solid', color: 'green', arrow: 'from' },
                { from: 'templates', to: 'studio', type: 'solid', color: 'green', arrow: 'from' },
                { from: 'studio', to: 'sistema', type: 'solid', color: 'green', arrow: 'from' },

                // LXP
                { from: 'organizacional', to: 'lxp', type: 'solid', color: 'cyan', arrow: 'from' },
                { from: 'usuarios', to: 'lxp', type: 'solid', color: 'cyan', arrow: 'from' },
                { from: 'relatorios', to: 'lxp', type: 'solid', color: 'cyan', arrow: 'from' },
                { from: 'lxp', to: 'sistema', type: 'dashed', color: 'cyan' },

                // Central
                { from: 'sistema', to: 'chatbot', type: 'solid', color: 'green', arrow: 'to' },

                // Chatbot Integrations
                { from: 'chatbot', to: 'int-lms', type: 'solid', color: 'violet', arrow: 'to' },
                { from: 'chatbot', to: 'int-classroom', type: 'solid', color: 'violet', arrow: 'to' },
                { from: 'chatbot', to: 'int-studio', type: 'solid', color: 'violet', arrow: 'to' },
                { from: 'chatbot', to: 'int-marketplace', type: 'solid', color: 'violet', arrow: 'to' },
            ]
        };

        // --- LÓGICA DO DIAGRAMA ---
        // (Geralmente não precisa mexer aqui)
        document.addEventListener('DOMContentLoaded', () => {
            const CONFIG = {
                DB_NAME: 'MindmapDB',
                STORE_NAME: 'diagramState',
                MIN_NODE_WIDTH: 120,
                MIN_NODE_HEIGHT: 80,
                ZOOM_FACTOR: 1.1,
                GRID_SIZE: 20,
                RESIZE_BORDER_THRESHOLD: 8,
                CONNECTION_CLICK_THRESHOLD: 10,
                CSS_CLASSES: {
                    NODE_RESIZING: 'resizing',
                    TOOLTIP_HIDDEN: 'hidden',
                    CONTEXT_MENU_HIDDEN: 'hidden',
                    BUTTON_ACTIVE: 'active',
                }
            };

            const appState = {
                db: null,
                nodesById: {},
                view: { scale: 1, panX: 0, panY: 0 },
                interaction: {
                    isPanning: false,
                    isDragging: false,
                    isResizing: false,
                    isConnecting: false,
                    draggedNode: null,
                    resizingNode: null,
                    resizeHandle: '',
                    resizeStart: { x: 0, y: 0 },
                    nodeStartRect: {},
                    panStart: { x: 0, y: 0 },
                    offsetX: 0,
                    offsetY: 0,
                    connectionStartNodeId: null,
                    selectedItem: null,
                    animationFrameRequest: null,
                },
            };

            const container = document.getElementById('diagram-container');
            const canvas = document.getElementById('diagram-canvas');
            const ctx = canvas.getContext('2d');

            const lineColors = {
                yellow: '#F59E0B',
                blue: '#3B82F6',
                green: '#22C55E',
                cyan: '#06B6D4',
                violet: '#A78BFA',
            };

            const tooltip = document.getElementById('tooltip');
            const contextMenu = document.getElementById('context-menu');

            function initDB(callback) {
                const request = indexedDB.open(CONFIG.DB_NAME, 1);
                request.onerror = (event) => console.error("Database error:", event.target.error);
                request.onsuccess = (event) => {
                    appState.db = event.target.result;
                    if (callback) callback();
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    db.createObjectStore(CONFIG.STORE_NAME, { keyPath: 'id' });
                };
            }
            
            function saveDiagramState() {
                if (!appState.db) return;
                const transaction = appState.db.transaction([CONFIG.STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CONFIG.STORE_NAME);
                const request = objectStore.put({ id: 'current', data: diagramData });
                
                request.onsuccess = () => {
                    const saveButton = document.getElementById('save-button');
                    saveButton.textContent = 'Salvo!';
                    saveButton.classList.add('saving');
                    setTimeout(() => {
                        saveButton.textContent = 'Salvar';
                        saveButton.classList.remove('saving');
                    }, 1500);
                };
                request.onerror = (event) => console.error("Error saving state:", event.target.error);
            }

            function loadDiagramState(callback) {
                if (!appState.db) return;
                const transaction = appState.db.transaction([CONFIG.STORE_NAME]);
                const objectStore = transaction.objectStore(CONFIG.STORE_NAME);
                const request = objectStore.get('current');

                request.onsuccess = (event) => {
                    if (request.result) {
                        // A simple merge to keep defaults for new properties
                        Object.assign(diagramData, request.result.data);
                    }
                    if (callback) callback();
                };
                request.onerror = (event) => {
                    console.error("Error loading state:", event.target.error);
                    if (callback) callback(); // still call callback on error
                };
            }

            function updateTransform() {
                const { panX, panY, scale } = appState.view;
                container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                const gridSize = CONFIG.GRID_SIZE;
                document.body.style.backgroundSize = `${gridSize * scale}px ${gridSize * scale}px`;
                document.body.style.backgroundPosition = `${panX}px ${panY}px`;
            }

            function renderNodes() {
                container.innerHTML = ''; // Limpa nós antigos, mas mantém o canvas
                container.appendChild(canvas);

                diagramData.nodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.id = nodeData.id;
                    nodeEl.className = 'node';
                    if (nodeData.color) {
                        nodeEl.classList.add(`color-${nodeData.color}`);
                    }
                    if (nodeData.isCentral) {
                        nodeEl.classList.add('central-node');
                    }
                    
                    if (nodeData.width) {
                        nodeEl.style.width = `${nodeData.width}px`;
                    }
                    if (nodeData.height) {
                        nodeEl.style.height = `${nodeData.height}px`;
                    }

                    nodeEl.style.left = `${nodeData.x}%`;
                    nodeEl.style.top = `${nodeData.y}%`;
                    
                    const titleEl = document.createElement('div');
                    titleEl.className = 'node-title';
                    titleEl.innerText = nodeData.title;
                    titleEl.contentEditable = false;
                    
                    const descEl = document.createElement('div');
                    descEl.className = 'node-description';
                    descEl.innerText = nodeData.description;
                    descEl.contentEditable = false;

                    // Save changes on blur
                    titleEl.addEventListener('blur', () => {
                        nodeData.title = titleEl.innerText;
                        titleEl.contentEditable = false;
                        titleEl.style.userSelect = 'none';
                    });
                    descEl.addEventListener('blur', () => {
                        nodeData.description = descEl.innerText;
                        descEl.contentEditable = false;
                        descEl.style.userSelect = 'none';
                    });

                    nodeEl.appendChild(titleEl);
                    nodeEl.appendChild(descEl);
                    container.appendChild(nodeEl);
                    
                    appState.nodesById[nodeData.id] = nodeEl;

                    nodeEl.addEventListener('mousemove', (e) => {
                        if (appState.interaction.isResizing) return;
                        const rect = nodeEl.getBoundingClientRect();
                        const borderThreshold = CONFIG.RESIZE_BORDER_THRESHOLD;

                        const onLeft = e.clientX - rect.left < borderThreshold;
                        const onRight = rect.right - e.clientX < borderThreshold;
                        const onTop = e.clientY - rect.top < borderThreshold;
                        const onBottom = rect.bottom - e.clientY < borderThreshold;

                        if ((onLeft && onTop) || (onRight && onBottom)) nodeEl.style.cursor = 'nwse-resize';
                        else if ((onRight && onTop) || (onLeft && onBottom)) nodeEl.style.cursor = 'nesw-resize';
                        else if (onRight || onLeft) nodeEl.style.cursor = 'ew-resize';
                        else if (onTop || onBottom) nodeEl.style.cursor = 'ns-resize';
                        else nodeEl.style.cursor = 'grab';
                    });

                    nodeEl.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return; // Only main button
                        
                        const rect = nodeEl.getBoundingClientRect();
                        const borderThreshold = CONFIG.RESIZE_BORDER_THRESHOLD;

                        const onLeft = e.clientX - rect.left < borderThreshold;
                        const onRight = rect.right - e.clientX < borderThreshold;
                        const onTop = e.clientY - rect.top < borderThreshold;
                        const onBottom = rect.bottom - e.clientY < borderThreshold;

                        const isResizeHandle = onLeft || onRight || onTop || onBottom;

                        if (isResizeHandle) {
                            appState.interaction.isResizing = true;
                            appState.interaction.resizingNode = nodeEl;
                            appState.interaction.resizingNode.classList.add(CONFIG.CSS_CLASSES.NODE_RESIZING);
                            
                            let handle = '';
                            if (onTop) handle += 'n';
                            if (onBottom) handle += 's';
                            if (onLeft) handle += 'w';
                            if (onRight) handle += 'e';
                            appState.interaction.resizeHandle = handle;

                            const parentRect = container.parentElement.getBoundingClientRect();
                            appState.interaction.resizeStart = { x: e.clientX, y: e.clientY };
                            appState.interaction.nodeStartRect = {
                                x: (rect.left - parentRect.left - appState.view.panX) / appState.view.scale,
                                y: (rect.top - parentRect.top - appState.view.panY) / appState.view.scale,
                                width: rect.width / appState.view.scale,
                                height: rect.height / appState.view.scale,
                            };

                            e.stopPropagation();
                        } else {
                            // Dragging logic
                            appState.interaction.isDragging = false;
                            appState.interaction.draggedNode = nodeEl;
                            container.style.cursor = 'grabbing';
                            nodeEl.style.cursor = 'grabbing';
                            const dragRect = nodeEl.getBoundingClientRect();
                            appState.interaction.offsetX = e.clientX - dragRect.left;
                            appState.interaction.offsetY = e.clientY - dragRect.top;
                            e.stopPropagation();
                        }
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    });
                });
            }

            function createElement(tag, options = {}) {
                const el = document.createElement(tag);
                for (const key in options) {
                    if (key === 'onClick') {
                        el.addEventListener('click', options[key]);
                    } else if (key === 'className') {
                        el.className = options[key];
                    } else if (key === 'textContent') {
                        el.textContent = options[key];
                    } else if (key in el.style) {
                        el.style[key] = options[key];
                    } else {
                        el.setAttribute(key, options[key]);
                    }
                }
                return el;
            }

            function getCanvasCoords(clientX, clientY) {
                const parentRect = container.parentElement.getBoundingClientRect();
                const mouseX = clientX - parentRect.left;
                const mouseY = clientY - parentRect.top;
        
                const x = (mouseX - appState.view.panX) / appState.view.scale;
                const y = (mouseY - appState.view.panY) / appState.view.scale;
                return { x, y };
            }
        
            function getCanvasPercentCoords(clientX, clientY) {
                const { x, y } = getCanvasCoords(clientX, clientY);
                return {
                    x: (x / container.offsetWidth) * 100,
                    y: (y / container.offsetHeight) * 100
                };
            }

            function drawArrow(ctx, x, y, angle) {
                const size = 8;
                ctx.save();
                ctx.fillStyle = ctx.strokeStyle;
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, -size / 2);
                ctx.lineTo(-size, size / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            function drawConnections() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                diagramData.connections.forEach(conn => {
                    const fromNode = appState.nodesById[conn.from];
                    const toNode = appState.nodesById[conn.to];

                    if (!fromNode || !toNode) return;

                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const fromCenterX = (fromRect.left + fromRect.width / 2) - containerRect.left;
                    const fromCenterY = (fromRect.top + fromRect.height / 2) - containerRect.top;
                    const toCenterX = (toRect.left + toRect.width / 2) - containerRect.left;
                    const toCenterY = (toRect.top + toRect.height / 2) - containerRect.top;
                    
                    const dx = toCenterX - fromCenterX;
                    const dy = toCenterY - fromCenterY;

                    let startX, startY, endX, endY;
                    let cp1x, cp1y, cp2x, cp2y;

                    if (Math.abs(dx) > Math.abs(dy)) { // More horizontal
                        startY = fromCenterY;
                        endY = toCenterY;
                        if (dx > 0) { // right
                            startX = fromRect.right - containerRect.left;
                            endX = toRect.left - containerRect.left;
                        } else { // left
                            startX = fromRect.left - containerRect.left;
                            endX = toRect.right - containerRect.left;
                        }
                        cp1x = fromCenterX + dx * 0.5;
                        cp1y = fromCenterY;
                        cp2x = fromCenterX + dx * 0.5;
                        cp2y = toCenterY;
                    } else { // More vertical
                        startX = fromCenterX;
                        endX = toCenterX;
                        if (dy > 0) { // down
                            startY = fromRect.bottom - containerRect.top;
                            endY = toRect.top - containerRect.top;
                        } else { // up
                            startY = fromRect.top - containerRect.top;
                            endY = toRect.bottom - containerRect.top;
                        }
                        cp1x = fromCenterX;
                        cp1y = fromCenterY + dy * 0.5;
                        cp2x = toCenterX;
                        cp2y = fromCenterY + dy * 0.5;
                    }
                    
                    ctx.strokeStyle = lineColors[conn.color] || '#4B5563'; // Use color from connection or default
                    ctx.lineWidth = 2;

                    // Define o estilo da linha (sólida ou pontilhada)
                    if (conn.type === 'dashed') {
                        ctx.setLineDash([5, 5]);
                    } else {
                        ctx.setLineDash([]);
                    }

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();
                    conn._renderData = { startX, startY, cp1x, cp1y, cp2x, cp2y, endX, endY }; // Cache for hit detection

                    if (conn.type === 'solid' && conn.arrow && conn.arrow !== 'none') {
                        const toAngle = Math.atan2(endY - cp2y, endX - cp2x);
                        const fromAngle = Math.atan2(startY - cp1y, startX - cp1x);

                        if (conn.arrow === 'to' || conn.arrow === 'both') {
                            drawArrow(ctx, endX, endY, toAngle);
                        }
                        if (conn.arrow === 'from' || conn.arrow === 'both') {
                            drawArrow(ctx, startX, startY, fromAngle);
                        }
                    }
                });
            }

            function renderSceneUpdate() {
                const { draggedNode, resizingNode } = appState.interaction;

                if (draggedNode) {
                    const nodeData = diagramData.nodes.find(n => n.id === draggedNode.id);
                    if (nodeData) {
                        draggedNode.style.left = `${nodeData.x}%`;
                        draggedNode.style.top = `${nodeData.y}%`;
                    }
                }

                if (resizingNode) {
                    const nodeData = diagramData.nodes.find(n => n.id === resizingNode.id);
                    if (nodeData) {
                        resizingNode.style.width = `${nodeData.width}px`;
                        resizingNode.style.height = `${nodeData.height}px`;
                        resizingNode.style.left = `${nodeData.x}%`;
                        resizingNode.style.top = `${nodeData.y}%`;
                    }
                }
                
                if (draggedNode || resizingNode) {
                    drawConnections();
                }
                
                appState.interaction.animationFrameRequest = null;
            }

            function scheduleSceneUpdate() {
                if (appState.interaction.animationFrameRequest) return;
                appState.interaction.animationFrameRequest = requestAnimationFrame(renderSceneUpdate);
            }
            
            function handleNodeResize(e) {
                e.preventDefault();
                const { resizingNode, resizeStart, resizeHandle, nodeStartRect } = appState.interaction;
                const { scale } = appState.view;
                const nodeData = diagramData.nodes.find(n => n.id === resizingNode.id);

                const dx = (e.clientX - resizeStart.x) / scale;
                const dy = (e.clientY - resizeStart.y) / scale;

                const minWidth = CONFIG.MIN_NODE_WIDTH;
                const minHeight = CONFIG.MIN_NODE_HEIGHT;
                
                let newX = nodeStartRect.x;
                let newY = nodeStartRect.y;
                let newWidth = nodeStartRect.width;
                let newHeight = nodeStartRect.height;

                if (resizeHandle.includes('e')) newWidth = nodeStartRect.width + dx;
                if (resizeHandle.includes('w')) {
                    newWidth = nodeStartRect.width - dx;
                    newX = nodeStartRect.x + dx;
                }
                if (resizeHandle.includes('s')) newHeight = nodeStartRect.height + dy;
                if (resizeHandle.includes('n')) {
                    newHeight = nodeStartRect.height - dy;
                    newY = nodeStartRect.y + dy;
                }
                
                if (newWidth < minWidth) {
                    if (resizeHandle.includes('w')) newX = nodeStartRect.x + nodeStartRect.width - minWidth;
                    newWidth = minWidth;
                }
                if (newHeight < minHeight) {
                    if (resizeHandle.includes('n')) newY = nodeStartRect.y + nodeStartRect.height - minHeight;
                    newHeight = minHeight;
                }

                const xPercent = (newX / container.offsetWidth) * 100;
                const yPercent = (newY / container.offsetHeight) * 100;

                if (nodeData) {
                    nodeData.width = newWidth;
                    nodeData.height = newHeight;
                    nodeData.x = xPercent;
                    nodeData.y = yPercent;
                }
                scheduleSceneUpdate();
            }

            function handlePanning(e) {
                appState.view.panX = e.clientX - appState.interaction.panStart.x;
                appState.view.panY = e.clientY - appState.interaction.panStart.y;
                updateTransform();
                drawConnections();
            }

            function handleNodeDrag(e) {
                e.preventDefault();
                appState.interaction.isDragging = true;

                const { x, y } = getCanvasCoords(e.clientX, e.clientY);
                const nodeX = x - appState.interaction.offsetX / appState.view.scale;
                const nodeY = y - appState.interaction.offsetY / appState.view.scale;

                const xPercent = (nodeX / container.offsetWidth) * 100;
                const yPercent = (nodeY / container.offsetHeight) * 100;

                const nodeData = diagramData.nodes.find(n => n.id === appState.interaction.draggedNode.id);
                if(nodeData) {
                    nodeData.x = xPercent;
                    nodeData.y = yPercent;
                }
                scheduleSceneUpdate();
            }

            function onMouseMove(e) {
                const { isResizing, isPanning, draggedNode } = appState.interaction;
                if (isResizing) return handleNodeResize(e);
                if (isPanning) return handlePanning(e);
                if (draggedNode) return handleNodeDrag(e);
            }

            function onMouseUp(e) {
                if (appState.interaction.animationFrameRequest) {
                    cancelAnimationFrame(appState.interaction.animationFrameRequest);
                    appState.interaction.animationFrameRequest = null;
                }

                const { isResizing, isConnecting, draggedNode, connectionStartNodeId, isDragging } = appState.interaction;

                if (isDragging || isResizing) {
                    // One final render to make sure everything is in place
                    renderSceneUpdate();
                }
                
                if (isResizing) {
                    appState.interaction.resizingNode.classList.remove(CONFIG.CSS_CLASSES.NODE_RESIZING);
                    appState.interaction.isResizing = false;
                    appState.interaction.resizingNode = null;
                    appState.interaction.resizeHandle = '';
                }

                const clickedNodeData = draggedNode ? diagramData.nodes.find(n => n.id === draggedNode.id) : null;
                
                if (isConnecting && clickedNodeData && connectionStartNodeId !== clickedNodeData.id) {
                    // Finalize connection
                    const newConnection = { from: connectionStartNodeId, to: clickedNodeData.id, type: 'solid', color: 'green', arrow: 'to' };
                    diagramData.connections.push(newConnection);
                    drawConnections();
                } else if (draggedNode && !isDragging) { // This is a click on a node
                    const target = e.target;
                    if (target.classList.contains('node-title') || target.classList.contains('node-description')) {
                        hideTooltip();
                        target.contentEditable = true;
                        target.style.userSelect = 'text';
                        target.focus();
                        // Select all text for easier editing
                        const selection = window.getSelection();
                        const range = document.createRange();
                        range.selectNodeContents(target);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } else {
                        showTooltip(e, clickedNodeData);
                    }
                }

                if (draggedNode) {
                    draggedNode.style.cursor = 'grab';
                }

                // Reset interaction state
                appState.interaction.isPanning = false;
                appState.interaction.isDragging = false;
                appState.interaction.draggedNode = null;
                appState.interaction.isConnecting = false;
                appState.interaction.connectionStartNodeId = null;
                container.style.cursor = 'default';

                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            function hideTooltip() {
                tooltip.classList.add(CONFIG.CSS_CLASSES.TOOLTIP_HIDDEN);
                tooltip.innerHTML = '';
                appState.interaction.selectedItem = null;
            }

            function hideContextMenu() {
                contextMenu.classList.add(CONFIG.CSS_CLASSES.CONTEXT_MENU_HIDDEN);
            }

            function showTooltip(e, item) {
                hideTooltip();
                appState.interaction.selectedItem = item;
                tooltip.classList.remove(CONFIG.CSS_CLASSES.TOOLTIP_HIDDEN);

                const availableColors = Object.keys(lineColors);

                if (item.hasOwnProperty('title')) { // Is a node
                    populateNodeTooltip(item, availableColors);
                    const nodeEl = appState.nodesById[item.id];
                    const nodeRect = nodeEl.getBoundingClientRect();
                    tooltip.style.left = `${nodeRect.left}px`;
                    tooltip.style.top = `${nodeRect.bottom + 10}px`;
                } else { // Is a connection
                    populateConnectionTooltip(item, availableColors);
                    tooltip.style.left = `${e.clientX}px`;
                    tooltip.style.top = `${e.clientY}px`;
                }
            }

            function populateNodeTooltip(node, colors) {
                const colorSection = createElement('div', { className: 'tooltip-section' });
                colors.forEach(colorName => {
                    const swatch = createElement('div', {
                        className: 'color-swatch',
                        onClick: () => {
                            const oldColor = node.color;
                            const nodeEl = appState.nodesById[node.id];
                            if (oldColor) nodeEl.classList.remove(`color-${oldColor}`);
                            nodeEl.classList.add(`color-${colorName}`);
                            node.color = colorName;
                            hideTooltip();
                        }
                    });
                    swatch.style.backgroundColor = lineColors[colorName];
                    colorSection.appendChild(swatch);
                });
                tooltip.appendChild(colorSection);

                // Actions Section
                const actionsSection = createElement('div', { className: 'tooltip-section' });

                const connectBtn = createElement('button', {
                    className: 'tooltip-button',
                    textContent: 'Conectar',
                    onClick: () => {
                        appState.interaction.isConnecting = true;
                        appState.interaction.connectionStartNodeId = node.id;
                        container.style.cursor = 'crosshair';
                        hideTooltip();
                    }
                });
                actionsSection.appendChild(connectBtn);

                const deleteBtn = createElement('button', {
                    className: 'tooltip-button delete',
                    textContent: 'Deletar',
                    onClick: () => {
                        // Remove node
                        diagramData.nodes = diagramData.nodes.filter(n => n.id !== node.id);
                        // Remove associated connections
                        diagramData.connections = diagramData.connections.filter(c => c.from !== node.id && c.to !== node.id);
                        hideTooltip();
                        initializeDiagram();
                    }
                });
                actionsSection.appendChild(deleteBtn);
                
                tooltip.appendChild(actionsSection);
            }

            function populateConnectionTooltip(conn, colors) {
                // Color section
                const colorSection = createElement('div', { className: 'tooltip-section' });
                colors.forEach(colorName => {
                    const swatch = createElement('div', {
                        className: 'color-swatch',
                        onClick: () => {
                            conn.color = colorName;
                            drawConnections();
                            hideTooltip();
                        }
                    });
                    swatch.style.backgroundColor = lineColors[colorName];
                    colorSection.appendChild(swatch);
                });
                tooltip.appendChild(colorSection);

                // Style section
                const styleSection = createElement('div', { className: 'tooltip-section' });
                ['solid', 'dashed'].forEach(style => {
                    const btn = createElement('button', {
                        className: `tooltip-button ${conn.type === style ? CONFIG.CSS_CLASSES.BUTTON_ACTIVE : ''}`,
                        textContent: style.charAt(0).toUpperCase() + style.slice(1),
                        onClick: () => {
                            conn.type = style;
                            drawConnections();
                            const tempEvent = { clientX: parseInt(tooltip.style.left), clientY: parseInt(tooltip.style.top) };
                            showTooltip(tempEvent, conn);
                        }
                    });
                    styleSection.appendChild(btn);
                });
                tooltip.appendChild(styleSection);

                // Arrow section
                const arrowSection = createElement('div', { className: 'tooltip-section' });
                ['none', 'from', 'to', 'both'].forEach(dir => {
                    const btn = createElement('button', {
                        className: `tooltip-button ${(conn.arrow || 'none') === dir ? CONFIG.CSS_CLASSES.BUTTON_ACTIVE : ''}`,
                        textContent: dir.charAt(0).toUpperCase() + dir.slice(1),
                        onClick: () => {
                            conn.arrow = dir;
                            drawConnections();
                            const tempEvent = { clientX: parseInt(tooltip.style.left), clientY: parseInt(tooltip.style.top) };
                            showTooltip(tempEvent, conn);
                        }
                    });
                    arrowSection.appendChild(btn);
                });
                tooltip.appendChild(arrowSection);

                // Delete Button Section
                const deleteSection = createElement('div', { className: 'tooltip-section' });
                const deleteBtn = createElement('button', {
                    className: 'tooltip-button delete',
                    textContent: 'Deletar',
                    onClick: () => {
                        diagramData.connections = diagramData.connections.filter(c => c !== conn);
                        hideTooltip();
                        drawConnections();
                    }
                });
                deleteSection.appendChild(deleteBtn);
                tooltip.appendChild(deleteSection);
            }

            function createNodeAtPosition(clientX, clientY) {
                const { x, y } = getCanvasPercentCoords(clientX, clientY);

                const newNode = {
                    id: `node_${Date.now()}`,
                    title: 'Novo Card',
                    description: 'Clique para editar o texto.',
                    x: x,
                    y: y,
                    color: 'green'
                };

                diagramData.nodes.push(newNode);
                initializeDiagram();
            }
            
            function getCanvasPoint(event) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }

            // Function to check distance from a point to a line segment
            function distToSegmentSquared(p, v, w) {
                const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
                if (l2 == 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return (p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2;
            }

            function isPointOnBezier(p, start, cp1, cp2, end, threshold) {
                const samples = 20;
                let prevPoint = start;
                for (let i = 1; i <= samples; i++) {
                    const t = i / samples;
                    const invT = 1 - t;
                    const x = invT**3 * start.x + 3 * invT**2 * t * cp1.x + 3 * invT * t**2 * cp2.x + t**3 * end.x;
                    const y = invT**3 * start.y + 3 * invT**2 * t * cp1.y + 3 * invT * t**2 * cp2.y + t**3 * end.y;
                    const currentPoint = {x, y};
                    if (distToSegmentSquared(p, prevPoint, currentPoint) < threshold**2) {
                        return true;
                    }
                    prevPoint = currentPoint;
                }
                return false;
            }

            container.addEventListener('mousedown', (e) => {
                // Background click
                if (e.target === container || e.target === canvas) {
                    hideTooltip();
                    hideContextMenu();
                    if (appState.interaction.isConnecting) {
                        appState.interaction.isConnecting = false;
                        appState.interaction.connectionStartNodeId = null;
                        container.style.cursor = 'default';
                    }
                }
                // Pan with middle mouse button, only if not dragging a node.
                if (e.button === 1 && !appState.interaction.draggedNode) {
                    appState.interaction.isPanning = true;
                    appState.interaction.panStart.x = e.clientX - appState.view.panX;
                    appState.interaction.panStart.y = e.clientY - appState.view.panY;
                    container.style.cursor = 'grabbing';
                    e.preventDefault();
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                }
            });

            canvas.addEventListener('click', (e) => {
                const point = getCanvasPoint(e);
                const threshold = CONFIG.CONNECTION_CLICK_THRESHOLD; // Click tolerance in pixels

                let clickedConnection = null;
                // Iterate backwards so we click the top-most connection
                for (const conn of [...diagramData.connections].reverse()) {
                    if (conn._renderData) {
                        const rd = conn._renderData;
                        const start = {x: rd.startX, y: rd.startY};
                        const cp1 = {x: rd.cp1x, y: rd.cp1y};
                        const cp2 = {x: rd.cp2x, y: rd.cp2y};
                        const end = {x: rd.endX, y: rd.endY};
                        if (isPointOnBezier(point, start, cp1, cp2, end, threshold)) {
                            clickedConnection = conn;
                            break;
                        }
                    }
                }

                if (clickedConnection) {
                    showTooltip(e, clickedConnection);
                }
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const oldScale = appState.view.scale;
                
                if (e.deltaY < 0) {
                    appState.view.scale *= CONFIG.ZOOM_FACTOR;
                } else {
                    appState.view.scale /= CONFIG.ZOOM_FACTOR;
                }
                appState.view.scale = Math.max(0.2, Math.min(appState.view.scale, 5));

                appState.view.panX = mouseX - (mouseX - appState.view.panX) * (appState.view.scale / oldScale);
                appState.view.panY = mouseY - (mouseY - appState.view.panY) * (appState.view.scale / oldScale);
                
                updateTransform();
                drawConnections();
            }, { passive: false });

            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (appState.interaction.draggedNode || appState.interaction.isPanning || e.target.closest('.node')) return;

                hideTooltip();
                contextMenu.classList.remove(CONFIG.CSS_CLASSES.CONTEXT_MENU_HIDDEN);
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;

                contextMenu.innerHTML = ''; // Clear old items

                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                menuItem.textContent = 'Criar novo card';
                menuItem.onclick = () => {
                    createNodeAtPosition(e.clientX, e.clientY);
                    hideContextMenu();
                };
                contextMenu.appendChild(menuItem);
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (appState.interaction.isConnecting) {
                        appState.interaction.isConnecting = false;
                        appState.interaction.connectionStartNodeId = null;
                        container.style.cursor = 'default';
                    }
                    // Check if an editable element inside a node has focus
                    if (document.activeElement && document.activeElement.isContentEditable && document.activeElement.closest('.node')) {
                        document.activeElement.blur();
                    }
                }
            });

            function initializeDiagram() {
                appState.nodesById = {};
                updateTransform();
                renderNodes();
                setTimeout(drawConnections, 100);
            }

            window.addEventListener('resize', drawConnections);

            initDB(() => {
                loadDiagramState(() => {
                    initializeDiagram();
                });
            });

            document.getElementById('save-button').addEventListener('click', saveDiagramState);
        });
    </script>
</body>
</html>
