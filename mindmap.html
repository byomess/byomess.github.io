<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sistema Educacional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0D0D0D;
            color: #F9FAFB;
            /* text-gray-50 */
            overflow: hidden;
            /* Hide scrollbars */
            --grid-color: rgba(255, 255, 255, 0.07);
            background-image:
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        }

        .diagram-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            transform-origin: top left;
        }

        .node {
            position: absolute;
            background-color: #1A1A1A;
            border: 1px solid #4B5563;
            /* border-gray-600 */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 200px;
            /* Largura padrão */
        }

        .node.resizing,
        .node.dragging {
            transition: none;
        }

        /* Card Styles */
        .node.style-border {
            background-color: transparent;
            border-width: 2px;
        }

        .node.style-filled {
            border: none;
        }

        .node.selected {
            box-shadow: 0 0 0 3px #3B82F6;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed #3B82F6;
            background-color: rgba(59, 130, 246, 0.2);
            z-index: 1000;
            pointer-events: none;
        }

        .node-title {
            font-weight: 600;
            color: #F9FAFB;
            /* text-gray-50 */
            margin-bottom: 0.5rem;
            user-select: none;
        }

        .node-description {
            font-size: 0.875rem;
            /* text-sm */
            color: #D1D5DB;
            /* text-gray-300 */
            line-height: 1.25;
            user-select: none;
        }

        #diagram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* Cores específicas para cada grupo */
        .color-slate {
            border-color: #64748B;
        }

        .color-gray {
            border-color: #6B7280;
        }

        .color-zinc {
            border-color: #71717A;
        }

        .color-neutral {
            border-color: #737373;
        }

        .color-stone {
            border-color: #78716C;
        }

        .color-red {
            border-color: #EF4444;
        }

        .color-orange {
            border-color: #F97316;
        }

        .color-amber {
            border-color: #F59E0B;
        }

        .color-yellow {
            border-color: #EAB308;
        }

        .color-lime {
            border-color: #84CC16;
        }

        .color-green {
            border-color: #22C55E;
        }

        .color-emerald {
            border-color: #10B981;
        }

        .color-teal {
            border-color: #14B8A6;
        }

        .color-cyan {
            border-color: #06B6D4;
        }

        .color-sky {
            border-color: #0EA5E9;
        }

        .color-blue {
            border-color: #3B82F6;
        }

        .color-indigo {
            border-color: #6366F1;
        }

        .color-violet {
            border-color: #8B5CF6;
        }

        .color-purple {
            border-color: #A855F7;
        }

        .color-fuchsia {
            border-color: #D946EF;
        }

        .color-pink {
            border-color: #EC4899;
        }

        .color-rose {
            border-color: #F43F5E;
        }

        .color-light-red {
            border-color: #F87171;
        }

        .color-light-orange {
            border-color: #FB923C;
        }

        .color-light-amber {
            border-color: #FBBF24;
        }

        .color-light-yellow {
            border-color: #FACC15;
        }

        .color-light-lime {
            border-color: #A3E635;
        }

        .color-light-green {
            border-color: #4ADE80;
        }

        .color-light-emerald {
            border-color: #34D399;
        }

        .color-light-teal {
            border-color: #2DD4BF;
        }

        /* Title colors to match border colors */
        .color-slate .node-title {
            color: #64748B;
        }

        .color-gray .node-title {
            color: #6B7280;
        }

        .color-zinc .node-title {
            color: #71717A;
        }

        .color-neutral .node-title {
            color: #737373;
        }

        .color-stone .node-title {
            color: #78716C;
        }

        .color-red .node-title {
            color: #EF4444;
        }

        .color-orange .node-title {
            color: #F97316;
        }

        .color-amber .node-title {
            color: #F59E0B;
        }

        .color-yellow .node-title {
            color: #EAB308;
        }

        .color-lime .node-title {
            color: #84CC16;
        }

        .color-green .node-title {
            color: #22C55E;
        }

        .color-emerald .node-title {
            color: #10B981;
        }

        .color-teal .node-title {
            color: #14B8A6;
        }

        .color-cyan .node-title {
            color: #06B6D4;
        }

        .color-sky .node-title {
            color: #0EA5E9;
        }

        .color-blue .node-title {
            color: #3B82F6;
        }

        .color-indigo .node-title {
            color: #6366F1;
        }

        .color-violet .node-title {
            color: #8B5CF6;
        }

        .color-purple .node-title {
            color: #A855F7;
        }

        .color-fuchsia .node-title {
            color: #D946EF;
        }

        .color-pink .node-title {
            color: #EC4899;
        }

        .color-rose .node-title {
            color: #F43F5E;
        }

        .color-light-red .node-title {
            color: #F87171;
        }

        .color-light-orange .node-title {
            color: #FB923C;
        }

        .color-light-amber .node-title {
            color: #FBBF24;
        }

        .color-light-yellow .node-title {
            color: #FACC15;
        }

        .color-light-lime .node-title {
            color: #A3E635;
        }

        .color-light-green .node-title {
            color: #4ADE80;
        }

        .color-light-emerald .node-title {
            color: #34D399;
        }

        .color-light-teal .node-title {
            color: #2DD4BF;
        }

        /* Filled Style Color Overrides */
        .style-filled.color-slate {
            background-color: #64748B;
        }

        .style-filled.color-gray {
            background-color: #6B7280;
        }

        .style-filled.color-zinc {
            background-color: #71717A;
        }

        .style-filled.color-neutral {
            background-color: #737373;
        }

        .style-filled.color-stone {
            background-color: #78716C;
        }

        .style-filled.color-red {
            background-color: #EF4444;
        }

        .style-filled.color-orange {
            background-color: #F97316;
        }

        .style-filled.color-amber {
            background-color: #F59E0B;
        }

        .style-filled.color-yellow {
            background-color: #EAB308;
        }

        .style-filled.color-lime {
            background-color: #84CC16;
        }

        .style-filled.color-green {
            background-color: #22C55E;
        }

        .style-filled.color-emerald {
            background-color: #10B981;
        }

        .style-filled.color-teal {
            background-color: #14B8A6;
        }

        .style-filled.color-cyan {
            background-color: #06B6D4;
        }

        .style-filled.color-sky {
            background-color: #0EA5E9;
        }

        .style-filled.color-blue {
            background-color: #3B82F6;
        }

        .style-filled.color-indigo {
            background-color: #6366F1;
        }

        .style-filled.color-violet {
            background-color: #8B5CF6;
        }

        .style-filled.color-purple {
            background-color: #A855F7;
        }

        .style-filled.color-fuchsia {
            background-color: #D946EF;
        }

        .style-filled.color-pink {
            background-color: #EC4899;
        }

        .style-filled.color-rose {
            background-color: #F43F5E;
        }

        .style-filled.color-light-red {
            background-color: #F87171;
        }

        .style-filled.color-light-orange {
            background-color: #FB923C;
        }

        .style-filled.color-light-amber {
            background-color: #FBBF24;
        }

        .style-filled.color-light-yellow {
            background-color: #FACC15;
        }

        .style-filled.color-light-lime {
            background-color: #A3E635;
        }

        .style-filled.color-light-green {
            background-color: #4ADE80;
        }

        .style-filled.color-light-emerald {
            background-color: #34D399;
        }

        .style-filled.color-light-teal {
            background-color: #2DD4BF;
        }

        .style-filled .node-title,
        .style-filled .node-description {
            color: #FFFFFF;
        }

        /* Some lighter colors might need darker text */
        .style-filled.color-lime .node-title,
        .style-filled.color-lime .node-description,
        .style-filled.color-yellow .node-title,
        .style-filled.color-yellow .node-description,
        .style-filled.color-amber .node-title,
        .style-filled.color-amber .node-description,
        .style-filled.color-light-amber .node-title,
        .style-filled.color-light-amber .node-description,
        .style-filled.color-light-yellow .node-title,
        .style-filled.color-light-yellow .node-description,
        .style-filled.color-light-lime .node-title,
        .style-filled.color-light-lime .node-description,
        .style-filled.color-light-green .node-title,
        .style-filled.color-light-green .node-description,
        .style-filled.color-light-emerald .node-title,
        .style-filled.color-light-emerald .node-description,
        .style-filled.color-light-teal .node-title,
        .style-filled.color-light-teal .node-description {
            color: #1A1A1A;
        }

        .central-node {
            border-width: 2px;
            background-color: #1A1A1A;
        }

        .tooltip {
            position: absolute;
            background-color: #2D3748;
            /* gray-800 */
            color: white;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #4A5568;
            /* gray-600 */
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            pointer-events: all;
        }

        .tooltip.hidden {
            display: none;
        }

        .tooltip-section {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .tooltip-section+.tooltip-section {
            border-left: 1px solid #4A5568;
            /* gray-600 */
            padding-left: 8px;
        }

        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .color-swatch:hover {
            border-color: white;
        }

        .tooltip-button {
            background: none;
            border: 1px solid #4A5568;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .tooltip-button:hover {
            background-color: #4A5568;
        }

        .tooltip-button.active {
            background-color: #3B82F6;
            /* blue-500 */
            border-color: #3B82F6;
        }

        .tooltip-button.delete {
            background-color: #E53E3E;
            /* red-600 */
        }

        .tooltip-button.delete:hover {
            background-color: #C53030;
            /* red-700 */
        }

        .context-menu {
            position: absolute;
            background-color: #2D3748;
            /* gray-800 */
            color: white;
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #4A5568;
            /* gray-600 */
            z-index: 101;
            pointer-events: all;
        }

        .context-menu.hidden {
            display: none;
        }

        .context-menu-item {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
        }

        .context-menu-item:hover {
            background-color: #4A5568;
        }

        .top-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 102;
            display: flex;
            gap: 10px;
        }

        .save-button {
            background-color: #3B82F6;
            /* blue-500 */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .save-button:hover {
            background-color: #2563EB;
            /* blue-600 */
        }

        .save-button.saving {
            background-color: #22C55E;
            /* green-500 */
        }

        .color-palette {
            position: absolute;
            background-color: #2D3748;
            border: 1px solid #4A5568;
            border-radius: 6px;
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            z-index: 101;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        .color-palette.hidden {
            display: none;
        }

        .connection-point {
            position: absolute;
            width: 14px;
            height: 14px;
            background-color: #3B82F6;
            border: 2px solid #1A1A1A;
            border-radius: 50%;
            z-index: 10;
            transform: translate(-50%, -50%);
            display: none;
            cursor: crosshair;
        }

        .diagram-container.is-reconnecting .connection-point {
            display: block;
        }
    </style>
</head>

<body>

    <div class="top-controls">
        <button id="save-button" class="save-button">Salvar</button>
        <button id="export-button" class="save-button">Exportar</button>
        <label for="import-file-input" class="save-button">Importar</label>
        <input type="file" id="import-file-input" accept="application/json" style="display: none;">
    </div>
    <div id="diagram-container" class="diagram-container">
        <canvas id="diagram-canvas"></canvas>
    </div>
    <div id="tooltip" class="tooltip hidden"></div>
    <div id="context-menu" class="context-menu hidden"></div>
    <div id="color-palette" class="color-palette hidden"></div>

    <script>
        // --- CONFIGURAÇÃO DO DIAGRAMA ---
        // Para personalizar, edite os nós e conexões abaixo.
        // Posições são em porcentagem (x: 0-100, y: 0-100)
        const diagramData = {
            "nodes": [
                {
                    "id": "vitrine",
                    "title": "Vitrine Personalizada",
                    "description": "Portfólio para criadores de conteúdo exibirem suas ofertas.",
                    "x": -2.5386385431334872,
                    "y": -6.7485215122992495,
                    "color": "yellow",
                    "width": 281.62182006835945,
                    "height": 106.46874923706058
                },
                {
                    "id": "licenciamento",
                    "title": "Gestão de Licenciamento",
                    "description": "Modelos flexíveis de preço para diferentes tipos de vendas.",
                    "x": -2.5532866627420487,
                    "y": 6.737714239947157,
                    "color": "yellow",
                    "width": 282.3843139648438,
                    "height": 98.89063110351566
                },
                {
                    "id": "avaliacoes",
                    "title": "Avaliações e Reviews",
                    "description": "Sistema para feedback da comunidade sobre os cursos.",
                    "x": -2.4470047464415927,
                    "y": 19.609817739107463,
                    "color": "yellow",
                    "width": 277.24068603515633,
                    "height": 96.7031188964844
                },
                {
                    "id": "marketplace",
                    "title": "Marketplace",
                    "description": "Espaço para publicação e venda de cursos educacionais.",
                    "x": 20.50172927315578,
                    "y": 6.907301298686769,
                    "color": "yellow",
                    "width": 279.8843383789063,
                    "height": 96.50002441406252
                },
                {
                    "id": "player",
                    "title": "Player de Conteúdo",
                    "description": "Interface unificada que apresenta todo o material didático.",
                    "x": -3.3115574068591576,
                    "y": 46.36617610043367,
                    "color": "red",
                    "width": 295.66877441406257,
                    "height": 95.4844177246094
                },
                {
                    "id": "forum",
                    "title": "Fórum de Dúvidas",
                    "description": "Espaço colaborativo para interações entre alunos e professores.",
                    "x": -3.313347771442489,
                    "y": 59.466812846967855,
                    "color": "red",
                    "width": 295.66877441406257,
                    "height": 97.59371337890627
                },
                {
                    "id": "gamificacao",
                    "title": "Gamificação",
                    "description": "Sistema de engajamento com pontos, medalhas e rankings.",
                    "x": -3.255730901833928,
                    "y": 72.7278112663567,
                    "color": "red",
                    "width": 292.39059448242193,
                    "height": 98.70002441406254
                },
                {
                    "id": "classroom",
                    "title": "Classroom",
                    "description": "Ambiente virtual onde os alunos interagem e aprendem.",
                    "x": 20.799609283331478,
                    "y": 59.475698648421826,
                    "color": "red",
                    "width": 277.3593872070313,
                    "height": 95.84381103515628
                },
                {
                    "id": "editor",
                    "title": "Editor Visual",
                    "description": "Interface intuitiva que permite arrastar e soltar elementos.",
                    "x": 87.12448375385574,
                    "y": -5.8732876784953545,
                    "color": "green",
                    "width": 288.00000000000006,
                    "height": 96.50000000000003
                },
                {
                    "id": "biblioteca",
                    "title": "Biblioteca de Mídias",
                    "description": "Gerenciamento centralizado de recursos educacionais e mídias.",
                    "x": 87.33281708718908,
                    "y": 6.592136452168504,
                    "color": "green",
                    "width": 279.00000000000006,
                    "height": 99.50000000000003
                },
                {
                    "id": "templates",
                    "title": "Templates de Conteúdo",
                    "description": "Modelos pré-configurados para facilitar a criação de atividades.",
                    "x": 87.28073375385574,
                    "y": 19.80176500854364,
                    "color": "green",
                    "width": 283.00000000000006,
                    "height": 103.00000000000001
                },
                {
                    "id": "studio",
                    "title": "Studio",
                    "description": "Ferramenta para criação de conteúdo interativo e dinâmico.",
                    "x": 62.47883177937895,
                    "y": 7.035364831654252,
                    "color": "green",
                    "width": 301.13403820800795,
                    "height": 91.84375241088871
                },
                {
                    "id": "organizacional",
                    "title": "Estrutura Organizacional",
                    "description": "Hierarquia visual para gerenciar cursos e turmas.",
                    "x": 87.4644580715979,
                    "y": 45.749111354453284,
                    "color": "cyan",
                    "width": 306.6876403808595,
                    "height": 98.5000183105469
                },
                {
                    "id": "usuarios",
                    "title": "Gestão de Usuários",
                    "description": "Controle de acesso e permissões para diferentes perfis.",
                    "x": 87.57839099904746,
                    "y": 58.54712177557915,
                    "color": "cyan",
                    "width": 304.49066162109386,
                    "height": 98.68753662109378
                },
                {
                    "id": "relatorios",
                    "title": "Relatórios Avançados",
                    "description": "Análises preditivas sobre desempenho e engajamento dos alunos.",
                    "x": 87.4644580715979,
                    "y": 70.94339674018005,
                    "color": "cyan",
                    "width": 303.375018310547,
                    "height": 100.67188720703128
                },
                {
                    "id": "lxp",
                    "title": "LXP",
                    "description": "Painel central para gerenciamento da estrutura institucional e experiência.",
                    "x": 62.647406704747155,
                    "y": 58.460848841329764,
                    "color": "cyan",
                    "width": 294.4688022460939,
                    "height": 102.7250267333985
                },
                {
                    "id": "sistema",
                    "title": "Sistema Educacional",
                    "description": "Um ecossistema completo de apps com diversos módulos interativos.",
                    "x": 41.812175114949554,
                    "y": 31.505530852789125,
                    "isCentral": true,
                    "width": 276.375,
                    "color": "slate",
                    "height": 101.784375
                },
                {
                    "id": "chatbot",
                    "title": "Chatbot",
                    "description": "Chat de assistência virtual com IA de ponta.",
                    "x": 41.44938393251817,
                    "y": 59.361825246373236,
                    "isCentral": true,
                    "width": 287.53123919451366,
                    "color": "violet",
                    "height": 100.01378033006624
                },
                {
                    "id": "int-lms",
                    "title": "Integração com LMS",
                    "description": "Facilita a gestão e automatiza tarefas administrativas.",
                    "x": 19.968658288303295,
                    "y": 86.60876089597295,
                    "color": "violet",
                    "width": 252.89061995577222,
                    "height": 99.49174360795455
                },
                {
                    "id": "int-classroom",
                    "title": "Integração com Classroom",
                    "description": "Ajuda os alunos, respondendo dúvidas e oferecendo suporte.",
                    "x": 34.889717909898785,
                    "y": 86.9865517646233,
                    "color": "violet",
                    "width": 258.6719355307335,
                    "height": 96.21904861828514
                },
                {
                    "id": "int-studio",
                    "title": "Integração com Studio",
                    "description": "Auxilia na geração de conteúdo através de Inteligência Artificial.",
                    "x": 49.83764067167403,
                    "y": 87.00048850357317,
                    "color": "violet",
                    "width": 253.70306850464877,
                    "height": 92.05554300103307
                },
                {
                    "id": "int-marketplace",
                    "title": "Integração com Marketplace",
                    "description": "Oferece sugestões inteligentes de cursos e conteúdos aos usuários.",
                    "x": 64.6850624491523,
                    "y": 87.03855674322192,
                    "color": "violet",
                    "width": 262.79690324767563,
                    "height": 92.89762638817149
                }
            ],
            "connections": [
                {
                    "from": "vitrine",
                    "to": "marketplace",
                    "type": "solid",
                    "color": "yellow",
                    "arrow": "from"
                },
                {
                    "from": "licenciamento",
                    "to": "marketplace",
                    "type": "solid",
                    "color": "yellow",
                    "arrow": "from"
                },
                {
                    "from": "avaliacoes",
                    "to": "marketplace",
                    "type": "solid",
                    "color": "yellow",
                    "arrow": "from"
                },
                {
                    "from": "marketplace",
                    "to": "sistema",
                    "type": "solid",
                    "color": "yellow",
                    "arrow": "from",
                    "fromSide": "right"
                },
                {
                    "from": "player",
                    "to": "classroom",
                    "type": "solid",
                    "color": "red",
                    "arrow": "from"
                },
                {
                    "from": "forum",
                    "to": "classroom",
                    "type": "solid",
                    "color": "red",
                    "arrow": "from"
                },
                {
                    "from": "gamificacao",
                    "to": "classroom",
                    "type": "solid",
                    "color": "red",
                    "arrow": "from"
                },
                {
                    "from": "editor",
                    "to": "studio",
                    "type": "solid",
                    "color": "green",
                    "arrow": "from"
                },
                {
                    "from": "biblioteca",
                    "to": "studio",
                    "type": "solid",
                    "color": "green",
                    "arrow": "from"
                },
                {
                    "from": "templates",
                    "to": "studio",
                    "type": "solid",
                    "color": "green",
                    "arrow": "from"
                },
                {
                    "from": "studio",
                    "to": "sistema",
                    "type": "solid",
                    "color": "green",
                    "arrow": "from"
                },
                {
                    "from": "organizacional",
                    "to": "lxp",
                    "type": "solid",
                    "color": "cyan",
                    "arrow": "from"
                },
                {
                    "from": "usuarios",
                    "to": "lxp",
                    "type": "solid",
                    "color": "cyan",
                    "arrow": "from"
                },
                {
                    "from": "relatorios",
                    "to": "lxp",
                    "type": "solid",
                    "color": "cyan",
                    "arrow": "from"
                },
                {
                    "from": "sistema",
                    "to": "chatbot",
                    "type": "solid",
                    "color": "violet",
                    "arrow": "to"
                },
                {
                    "from": "chatbot",
                    "to": "int-lms",
                    "type": "solid",
                    "color": "violet",
                    "arrow": "to",
                    "toSide": "top",
                    "fromSide": "bottom"
                },
                {
                    "from": "chatbot",
                    "to": "int-classroom",
                    "type": "solid",
                    "color": "violet",
                    "arrow": "to",
                    "toSide": "top"
                },
                {
                    "from": "chatbot",
                    "to": "int-studio",
                    "type": "solid",
                    "color": "violet",
                    "arrow": "to"
                },
                {
                    "from": "chatbot",
                    "to": "int-marketplace",
                    "type": "solid",
                    "color": "violet",
                    "arrow": "to",
                    "fromSide": "bottom",
                    "toSide": "top"
                },
                {
                    "from": "classroom",
                    "to": "sistema",
                    "type": "solid",
                    "color": "red",
                    "arrow": "from",
                    "fromSide": "right"
                },
                {
                    "from": "lxp",
                    "to": "sistema",
                    "type": "solid",
                    "color": "cyan",
                    "arrow": "from"
                }
            ]
        };

        // --- LÓGICA DO DIAGRAMA ---
        // (Geralmente não precisa mexer aqui)
        document.addEventListener('DOMContentLoaded', () => {
            const CONFIG = {
                DB_NAME: 'MindmapDB',
                STORE_NAME: 'diagramState',
                MIN_NODE_WIDTH: 120,
                MIN_NODE_HEIGHT: 80,
                ZOOM_FACTOR: 1.1,
                GRID_SIZE: 20,
                RESIZE_BORDER_THRESHOLD: 8,
                CONNECTION_CLICK_THRESHOLD: 10,
                CSS_CLASSES: {
                    NODE_DRAGGING: 'dragging',
                    NODE_RESIZING: 'resizing',
                    NODE_SELECTED: 'selected',
                    TOOLTIP_HIDDEN: 'hidden',
                    CONTEXT_MENU_HIDDEN: 'hidden',
                    BUTTON_ACTIVE: 'active',
                }
            };

            const appState = {
                db: null,
                nodesById: {},
                view: { scale: 1, panX: 0, panY: 0 },
                interaction: {
                    isPanning: false,
                    isDragging: false,
                    isResizing: false,
                    isConnecting: false,
                    isReconnecting: false,
                    reconnectingConnection: null,
                    reconnectingEnd: null, // 'from' or 'to'
                    reconnectingMousePos: { x: 0, y: 0 },
                    isSelecting: false,
                    selectionBox: null,
                    selectionStart: { x: 0, y: 0 },
                    draggedNode: null,
                    resizingNode: null,
                    resizeHandle: '',
                    resizeStart: { x: 0, y: 0 },
                    nodeStartRect: {},
                    panStart: { x: 0, y: 0 },
                    offsetX: 0,
                    offsetY: 0,
                    connectionStartNodeId: null,
                    selectedItem: null,
                    selectedNodes: new Set(),
                    dragStartPositions: new Map(),
                    animationFrameRequest: null,
                },
            };

            const container = document.getElementById('diagram-container');
            const canvas = document.getElementById('diagram-canvas');
            const ctx = canvas.getContext('2d');

            const lineColors = {
                slate: '#64748B',
                gray: '#6B7280',
                zinc: '#71717A',
                neutral: '#737373',
                stone: '#78716C',
                red: '#EF4444',
                orange: '#F97316',
                amber: '#F59E0B',
                yellow: '#EAB308',
                lime: '#84CC16',
                green: '#22C55E',
                emerald: '#10B981',
                teal: '#14B8A6',
                cyan: '#06B6D4',
                sky: '#0EA5E9',
                blue: '#3B82F6',
                indigo: '#6366F1',
                violet: '#8B5CF6',
                purple: '#A855F7',
                fuchsia: '#D946EF',
                pink: '#EC4899',
                rose: '#F43F5E',
                'light-red': '#F87171',
                'light-orange': '#FB923C',
                'light-amber': '#FBBF24',
                'light-yellow': '#FACC15',
                'light-lime': '#A3E635',
                'light-green': '#4ADE80',
                'light-emerald': '#34D399',
                'light-teal': '#2DD4BF',
            };

            const tooltip = document.getElementById('tooltip');
            const contextMenu = document.getElementById('context-menu');
            const colorPalette = document.getElementById('color-palette');

            function initDB(callback) {
                const request = indexedDB.open(CONFIG.DB_NAME, 1);
                request.onerror = (event) => console.error("Database error:", event.target.error);
                request.onsuccess = (event) => {
                    appState.db = event.target.result;
                    if (callback) callback();
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    db.createObjectStore(CONFIG.STORE_NAME, { keyPath: 'id' });
                };
            }

            function saveDiagramState() {
                if (!appState.db) return;
                const transaction = appState.db.transaction([CONFIG.STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CONFIG.STORE_NAME);
                const request = objectStore.put({ id: 'current', data: diagramData });

                request.onsuccess = () => {
                    const saveButton = document.getElementById('save-button');
                    saveButton.textContent = 'Salvo!';
                    saveButton.classList.add('saving');
                    setTimeout(() => {
                        saveButton.textContent = 'Salvar';
                        saveButton.classList.remove('saving');
                    }, 1500);
                };
                request.onerror = (event) => console.error("Error saving state:", event.target.error);
            }

            function loadDiagramState(callback) {
                if (!appState.db) return;
                const transaction = appState.db.transaction([CONFIG.STORE_NAME]);
                const objectStore = transaction.objectStore(CONFIG.STORE_NAME);
                const request = objectStore.get('current');

                request.onsuccess = (event) => {
                    if (request.result) {
                        // A simple merge to keep defaults for new properties
                        Object.assign(diagramData, request.result.data);
                    }
                    if (callback) callback();
                };
                request.onerror = (event) => {
                    console.error("Error loading state:", event.target.error);
                    if (callback) callback(); // still call callback on error
                };
            }

            function updateTransform() {
                const { panX, panY, scale } = appState.view;
                container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                const gridSize = CONFIG.GRID_SIZE;
                document.body.style.backgroundSize = `${gridSize * scale}px ${gridSize * scale}px`;
                document.body.style.backgroundPosition = `${panX}px ${panY}px`;
            }

            function renderNodes() {
                container.innerHTML = ''; // Limpa nós antigos, mas mantém o canvas
                container.appendChild(canvas);

                diagramData.nodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.id = nodeData.id;
                    nodeEl.className = 'node';
                    if (nodeData.style && nodeData.style !== 'default') {
                        nodeEl.classList.add(`style-${nodeData.style}`);
                    }
                    if (nodeData.color) {
                        nodeEl.classList.add(`color-${nodeData.color}`);
                    }
                    if (nodeData.isCentral) {
                        nodeEl.classList.add('central-node');
                    }
                    if (appState.interaction.selectedNodes.has(nodeData.id)) {
                        nodeEl.classList.add(CONFIG.CSS_CLASSES.NODE_SELECTED);
                    }

                    if (nodeData.width) {
                        nodeEl.style.width = `${nodeData.width}px`;
                    }
                    if (nodeData.height) {
                        nodeEl.style.height = `${nodeData.height}px`;
                    }

                    nodeEl.style.left = `${nodeData.x}%`;
                    nodeEl.style.top = `${nodeData.y}%`;

                    const titleEl = document.createElement('div');
                    titleEl.className = 'node-title';
                    titleEl.innerText = nodeData.title;
                    titleEl.contentEditable = false;

                    const descEl = document.createElement('div');
                    descEl.className = 'node-description';
                    descEl.innerText = nodeData.description;
                    descEl.contentEditable = false;

                    // Save changes on blur
                    titleEl.addEventListener('blur', () => {
                        nodeData.title = titleEl.innerText;
                        titleEl.contentEditable = false;
                        titleEl.style.userSelect = 'none';
                    });
                    descEl.addEventListener('blur', () => {
                        nodeData.description = descEl.innerText;
                        descEl.contentEditable = false;
                        descEl.style.userSelect = 'none';
                    });

                    nodeEl.appendChild(titleEl);
                    nodeEl.appendChild(descEl);

                    // Add connection points
                    ['top', 'right', 'bottom', 'left'].forEach(side => {
                        const point = document.createElement('div');
                        point.className = `connection-point ${side}`;
                        point.dataset.nodeId = nodeData.id;
                        point.dataset.side = side;

                        if (side === 'top') { point.style.top = '0%'; point.style.left = '50%'; }
                        if (side === 'right') { point.style.top = '50%'; point.style.left = '100%'; }
                        if (side === 'bottom') { point.style.top = '100%'; point.style.left = '50%'; }
                        if (side === 'left') { point.style.top = '50%'; point.style.left = '0%'; }

                        nodeEl.appendChild(point);
                    });

                    container.appendChild(nodeEl);

                    appState.nodesById[nodeData.id] = nodeEl;

                    nodeEl.addEventListener('mousemove', (e) => {
                        if (appState.interaction.isResizing) return;
                        const rect = nodeEl.getBoundingClientRect();
                        const borderThreshold = CONFIG.RESIZE_BORDER_THRESHOLD;

                        const onLeft = e.clientX - rect.left < borderThreshold;
                        const onRight = rect.right - e.clientX < borderThreshold;
                        const onTop = e.clientY - rect.top < borderThreshold;
                        const onBottom = rect.bottom - e.clientY < borderThreshold;

                        if ((onLeft && onTop) || (onRight && onBottom)) nodeEl.style.cursor = 'nwse-resize';
                        else if ((onRight && onTop) || (onLeft && onBottom)) nodeEl.style.cursor = 'nesw-resize';
                        else if (onRight || onLeft) nodeEl.style.cursor = 'ew-resize';
                        else if (onTop || onBottom) nodeEl.style.cursor = 'ns-resize';
                        else nodeEl.style.cursor = 'grab';
                    });

                    nodeEl.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return; // Only main button

                        const rect = nodeEl.getBoundingClientRect();
                        const borderThreshold = CONFIG.RESIZE_BORDER_THRESHOLD;

                        const onLeft = e.clientX - rect.left < borderThreshold;
                        const onRight = rect.right - e.clientX < borderThreshold;
                        const onTop = e.clientY - rect.top < borderThreshold;
                        const onBottom = rect.bottom - e.clientY < borderThreshold;

                        const isResizeHandle = onLeft || onRight || onTop || onBottom;

                        if (isResizeHandle) {
                            appState.interaction.isResizing = true;
                            appState.interaction.resizingNode = nodeEl;
                            appState.interaction.resizingNode.classList.add(CONFIG.CSS_CLASSES.NODE_RESIZING);

                            let handle = '';
                            if (onTop) handle += 'n';
                            if (onBottom) handle += 's';
                            if (onLeft) handle += 'w';
                            if (onRight) handle += 'e';
                            appState.interaction.resizeHandle = handle;

                            const parentRect = container.parentElement.getBoundingClientRect();
                            appState.interaction.resizeStart = { x: e.clientX, y: e.clientY };
                            appState.interaction.nodeStartRect = {
                                x: (rect.left - parentRect.left - appState.view.panX) / appState.view.scale,
                                y: (rect.top - parentRect.top - appState.view.panY) / appState.view.scale,
                                width: rect.width / appState.view.scale,
                                height: rect.height / appState.view.scale,
                            };

                            e.stopPropagation();
                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('mouseup', onMouseUp);
                        } else {
                            if (e.ctrlKey) {
                                if (appState.interaction.selectedNodes.has(nodeEl.id)) {
                                    removeNodeFromSelection(nodeEl.id);
                                } else {
                                    addNodeToSelection(nodeEl.id);
                                }
                                e.stopPropagation();
                            } else {
                                // Dragging logic
                                if (!appState.interaction.selectedNodes.has(nodeEl.id)) {
                                    clearSelection();
                                    addNodeToSelection(nodeEl.id);
                                }

                                appState.interaction.isDragging = false; // Will be set to true on first mouse move
                                appState.interaction.draggedNode = nodeEl;

                                appState.interaction.dragStartPositions.clear();
                                appState.interaction.selectedNodes.forEach(id => {
                                    const nodeData = diagramData.nodes.find(n => n.id === id);
                                    if (nodeData) {
                                        appState.interaction.dragStartPositions.set(id, { x: nodeData.x, y: nodeData.y });
                                    }
                                });

                                container.style.cursor = 'grabbing';
                                nodeEl.style.cursor = 'grabbing';
                                const dragRect = nodeEl.getBoundingClientRect();
                                appState.interaction.offsetX = e.clientX - dragRect.left;
                                appState.interaction.offsetY = e.clientY - dragRect.top;
                                e.stopPropagation();
                                document.addEventListener('mousemove', onMouseMove);
                                document.addEventListener('mouseup', onMouseUp);
                            }
                        }
                    });
                });
            }

            function createElement(tag, options = {}) {
                const el = document.createElement(tag);
                for (const key in options) {
                    if (key === 'onClick') {
                        el.addEventListener('click', options[key]);
                    } else if (key === 'className') {
                        el.className = options[key];
                    } else if (key === 'textContent') {
                        el.textContent = options[key];
                    } else if (key in el.style) {
                        el.style[key] = options[key];
                    } else {
                        el.setAttribute(key, options[key]);
                    }
                }
                return el;
            }

            function addNodeToSelection(nodeId) {
                if (!appState.interaction.selectedNodes.has(nodeId)) {
                    appState.interaction.selectedNodes.add(nodeId);
                    appState.nodesById[nodeId]?.classList.add(CONFIG.CSS_CLASSES.NODE_SELECTED);
                }
            }

            function clearSelection() {
                appState.interaction.selectedNodes.forEach(id => {
                    appState.nodesById[id]?.classList.remove(CONFIG.CSS_CLASSES.NODE_SELECTED);
                });
                appState.interaction.selectedNodes.clear();
            }

            function removeNodeFromSelection(nodeId) {
                if (appState.interaction.selectedNodes.has(nodeId)) {
                    appState.interaction.selectedNodes.delete(nodeId);
                    appState.nodesById[nodeId]?.classList.remove(CONFIG.CSS_CLASSES.NODE_SELECTED);
                }
            }

            function getCanvasCoords(clientX, clientY) {
                const parentRect = container.parentElement.getBoundingClientRect();
                const mouseX = clientX - parentRect.left;
                const mouseY = clientY - parentRect.top;

                const x = (mouseX - appState.view.panX) / appState.view.scale;
                const y = (mouseY - appState.view.panY) / appState.view.scale;
                return { x, y };
            }

            function getCanvasPercentCoords(clientX, clientY) {
                const { x, y } = getCanvasCoords(clientX, clientY);
                return {
                    x: (x / container.offsetWidth) * 100,
                    y: (y / container.offsetHeight) * 100
                };
            }

            function drawArrow(ctx, x, y, angle) {
                const size = 8;
                ctx.save();
                ctx.fillStyle = ctx.strokeStyle;
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, -size / 2);
                ctx.lineTo(-size, size / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            function getAnchorPoint(rect, side) {
                switch (side) {
                    case 'top': return { x: rect.left + rect.width / 2, y: rect.top };
                    case 'right': return { x: rect.right, y: rect.top + rect.height / 2 };
                    case 'bottom': return { x: rect.left + rect.width / 2, y: rect.bottom };
                    case 'left': return { x: rect.left, y: rect.top + rect.height / 2 };
                    default: return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                }
            }

            function drawConnections() {
                const baseWidth = container.offsetWidth;
                const baseHeight = container.offsetHeight;

                const newWidth = baseWidth * 3;
                const newHeight = baseHeight * 3;

                canvas.width = newWidth;
                canvas.height = newHeight;
                canvas.style.width = `${newWidth}px`;
                canvas.style.height = `${newHeight}px`;

                canvas.style.left = `-${baseWidth}px`;
                canvas.style.top = `-${baseHeight}px`;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(baseWidth, baseHeight);

                const { isReconnecting, reconnectingConnection, reconnectingEnd, reconnectingMousePos } = appState.interaction;

                diagramData.connections.forEach(conn => {
                    let startX, startY, endX, endY;
                    let cp1x, cp1y, cp2x, cp2y;

                    const fromNode = appState.nodesById[conn.from];
                    const toNode = appState.nodesById[conn.to];

                    if (!fromNode || !toNode) return;

                    const fromRect = {
                        left: fromNode.offsetLeft, top: fromNode.offsetTop,
                        width: fromNode.offsetWidth, height: fromNode.offsetHeight,
                        right: fromNode.offsetLeft + fromNode.offsetWidth,
                        bottom: fromNode.offsetTop + fromNode.offsetHeight
                    };
                    const toRect = {
                        left: toNode.offsetLeft, top: toNode.offsetTop,
                        width: toNode.offsetWidth, height: toNode.offsetHeight,
                        right: toNode.offsetLeft + toNode.offsetWidth,
                        bottom: toNode.offsetTop + toNode.offsetHeight
                    };

                    const fromCenterX = fromRect.left + fromRect.width / 2;
                    const fromCenterY = fromRect.top + fromRect.height / 2;
                    const toCenterX = toRect.left + toRect.width / 2;
                    const toCenterY = toRect.top + toRect.height / 2;

                    let fromSide = conn.fromSide;
                    let toSide = conn.toSide;
                    let startPoint, endPoint;

                    if (isReconnecting && conn === reconnectingConnection) {
                        const mousePos = reconnectingMousePos;
                        if (reconnectingEnd === 'from') {
                            startPoint = mousePos;
                            toSide = conn.toSide;
                            if (!toSide) {
                                const dx = toCenterX - fromCenterX;
                                const dy = toCenterY - fromCenterY;
                                toSide = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'left' : 'right') : (dy > 0 ? 'top' : 'bottom');
                            }
                            endPoint = getAnchorPoint(toRect, toSide);
                            const dx = endPoint.x - startPoint.x;
                            const dy = endPoint.y - startPoint.y;
                            fromSide = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'bottom' : 'top');
                        } else { // 'to'
                            endPoint = mousePos;
                            fromSide = conn.fromSide;
                            if (!fromSide) {
                                const dx = toCenterX - fromCenterX;
                                const dy = toCenterY - fromCenterY;
                                fromSide = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'bottom' : 'top');
                            }
                            startPoint = getAnchorPoint(fromRect, fromSide);
                            const dx = endPoint.x - startPoint.x;
                            const dy = endPoint.y - startPoint.y;
                            toSide = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'left' : 'right') : (dy > 0 ? 'top' : 'bottom');
                        }
                    } else {
                        if (!fromSide || !toSide) {
                            const dx = toCenterX - fromCenterX;
                            const dy = toCenterY - fromCenterY;
                            if (Math.abs(dx) > Math.abs(dy)) {
                                fromSide = fromSide || (dx > 0 ? 'right' : 'left');
                                toSide = toSide || (dx > 0 ? 'left' : 'right');
                            } else {
                                fromSide = fromSide || (dy > 0 ? 'bottom' : 'top');
                                toSide = toSide || (dy > 0 ? 'top' : 'bottom');
                            }
                        }
                        startPoint = getAnchorPoint(fromRect, fromSide);
                        endPoint = getAnchorPoint(toRect, toSide);
                    }

                    startX = startPoint.x; startY = startPoint.y;
                    endX = endPoint.x; endY = endPoint.y;

                    if (fromSide === 'left' || fromSide === 'right') {
                        // Horizontal S-curve
                        cp1x = startX + (endX - startX) / 2;
                        cp1y = startY;
                        cp2x = startX + (endX - startX) / 2;
                        cp2y = endY;
                    } else { // 'top' or 'bottom'
                        // Vertical S-curve
                        cp1x = startX;
                        cp1y = startY + (endY - startY) / 2;
                        cp2x = endX;
                        cp2y = startY + (endY - startY) / 2;
                    }

                    ctx.strokeStyle = lineColors[conn.color] || '#4B5563';
                    ctx.lineWidth = 2;

                    if (conn.type === 'dashed') ctx.setLineDash([5, 5]);
                    else ctx.setLineDash([]);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);

                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);

                    ctx.stroke();
                    conn._renderData = { startX, startY, cp1x, cp1y, cp2x, cp2y, endX, endY };

                    if (conn.type === 'solid' && conn.arrow && conn.arrow !== 'none') {
                        const toAngle = Math.atan2(endY - (cp2y || startY), endX - (cp2x || startX));
                        const fromAngle = Math.atan2(startY - (cp1y || endY), startX - (cp1x || endX));

                        if (conn.arrow === 'to' || conn.arrow === 'both') drawArrow(ctx, endX, endY, toAngle);
                        if (conn.arrow === 'from' || conn.arrow === 'both') drawArrow(ctx, startX, startY, fromAngle);
                    }
                });
                ctx.restore();
            }

            function renderSceneUpdate() {
                const { draggedNode, resizingNode } = appState.interaction;

                if (draggedNode) {
                    appState.interaction.selectedNodes.forEach(id => {
                        const nodeData = diagramData.nodes.find(n => n.id === id);
                        const nodeEl = appState.nodesById[id];
                        if (nodeData && nodeEl) {
                            nodeEl.style.left = `${nodeData.x}%`;
                            nodeEl.style.top = `${nodeData.y}%`;
                        }
                    });
                }

                if (resizingNode) {
                    const nodeData = diagramData.nodes.find(n => n.id === resizingNode.id);
                    if (nodeData) {
                        resizingNode.style.width = `${nodeData.width}px`;
                        resizingNode.style.height = `${nodeData.height}px`;
                        resizingNode.style.left = `${nodeData.x}%`;
                        resizingNode.style.top = `${nodeData.y}%`;
                    }
                }

                if (draggedNode || resizingNode || appState.interaction.isReconnecting) {
                    drawConnections();
                }

                appState.interaction.animationFrameRequest = null;
            }

            function scheduleSceneUpdate() {
                if (appState.interaction.animationFrameRequest) return;
                appState.interaction.animationFrameRequest = requestAnimationFrame(renderSceneUpdate);
            }

            function handleReconnecting(e) {
                appState.interaction.reconnectingMousePos = getCanvasCoords(e.clientX, e.clientY);
                scheduleSceneUpdate();
            }

            function handleNodeResize(e) {
                e.preventDefault();
                const { resizingNode, resizeStart, resizeHandle, nodeStartRect } = appState.interaction;
                const { scale } = appState.view;
                const nodeData = diagramData.nodes.find(n => n.id === resizingNode.id);

                const dx = (e.clientX - resizeStart.x) / scale;
                const dy = (e.clientY - resizeStart.y) / scale;

                const minWidth = CONFIG.MIN_NODE_WIDTH;
                const minHeight = CONFIG.MIN_NODE_HEIGHT;

                let newX = nodeStartRect.x;
                let newY = nodeStartRect.y;
                let newWidth = nodeStartRect.width;
                let newHeight = nodeStartRect.height;

                if (resizeHandle.includes('e')) newWidth = nodeStartRect.width + dx;
                if (resizeHandle.includes('w')) {
                    newWidth = nodeStartRect.width - dx;
                    newX = nodeStartRect.x + dx;
                }
                if (resizeHandle.includes('s')) newHeight = nodeStartRect.height + dy;
                if (resizeHandle.includes('n')) {
                    newHeight = nodeStartRect.height - dy;
                    newY = nodeStartRect.y + dy;
                }

                if (newWidth < minWidth) {
                    if (resizeHandle.includes('w')) newX = nodeStartRect.x + nodeStartRect.width - minWidth;
                    newWidth = minWidth;
                }
                if (newHeight < minHeight) {
                    if (resizeHandle.includes('n')) newY = nodeStartRect.y + nodeStartRect.height - minHeight;
                    newHeight = minHeight;
                }

                const xPercent = (newX / container.offsetWidth) * 100;
                const yPercent = (newY / container.offsetHeight) * 100;

                if (nodeData) {
                    nodeData.width = newWidth;
                    nodeData.height = newHeight;
                    nodeData.x = xPercent;
                    nodeData.y = yPercent;
                }
                scheduleSceneUpdate();
            }

            function handlePanning(e) {
                appState.view.panX = e.clientX - appState.interaction.panStart.x;
                appState.view.panY = e.clientY - appState.interaction.panStart.y;
                updateTransform();
                drawConnections();
            }

            function handleNodeDrag(e) {
                e.preventDefault();
                if (!appState.interaction.isDragging) {
                    appState.interaction.draggedNode.classList.add(CONFIG.CSS_CLASSES.NODE_DRAGGING);
                    appState.interaction.selectedNodes.forEach(id => {
                        if (id !== appState.interaction.draggedNode.id) {
                            appState.nodesById[id]?.classList.add(CONFIG.CSS_CLASSES.NODE_DRAGGING);
                        }
                    });
                }
                appState.interaction.isDragging = true;

                const { x, y } = getCanvasCoords(e.clientX, e.clientY);
                const draggedNodeX = x - appState.interaction.offsetX / appState.view.scale;
                const draggedNodeY = y - appState.interaction.offsetY / appState.view.scale;

                const draggedNodeXPercent = (draggedNodeX / container.offsetWidth) * 100;
                const draggedNodeYPercent = (draggedNodeY / container.offsetHeight) * 100;

                const draggedNodeId = appState.interaction.draggedNode.id;
                const dragStartPosition = appState.interaction.dragStartPositions.get(draggedNodeId);

                if (dragStartPosition) {
                    const deltaX = draggedNodeXPercent - dragStartPosition.x;
                    const deltaY = draggedNodeYPercent - dragStartPosition.y;

                    appState.interaction.selectedNodes.forEach(id => {
                        const nodeData = diagramData.nodes.find(n => n.id === id);
                        const startPos = appState.interaction.dragStartPositions.get(id);
                        if (nodeData && startPos) {
                            nodeData.x = startPos.x + deltaX;
                            nodeData.y = startPos.y + deltaY;
                        }
                    });
                }
                scheduleSceneUpdate();
            }

            function handleSelectionRect(e) {
                const { selectionStart, selectionBox } = appState.interaction;
                const { x: currentX, y: currentY } = getCanvasCoords(e.clientX, e.clientY);

                const left = Math.min(selectionStart.x, currentX);
                const top = Math.min(selectionStart.y, currentY);
                const width = Math.abs(currentX - selectionStart.x);
                const height = Math.abs(currentY - selectionStart.y);

                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;
            }

            function onMouseMove(e) {
                const { isResizing, isPanning, draggedNode, isSelecting, isReconnecting } = appState.interaction;
                if (isReconnecting) return handleReconnecting(e);
                if (isResizing) return handleNodeResize(e);
                if (isPanning) return handlePanning(e);
                if (draggedNode) return handleNodeDrag(e);
                if (isSelecting) return handleSelectionRect(e);
            }

            function onMouseUp(e) {
                if (appState.interaction.animationFrameRequest) {
                    cancelAnimationFrame(appState.interaction.animationFrameRequest);
                    appState.interaction.animationFrameRequest = null;
                }

                const { isResizing, isConnecting, draggedNode, connectionStartNodeId, isDragging, isSelecting, selectionBox, isReconnecting, reconnectingConnection, reconnectingEnd } = appState.interaction;

                if (isReconnecting) {
                    container.classList.remove('is-reconnecting');
                    const target = e.target;
                    if (target.classList.contains('connection-point')) {
                        const nodeId = target.dataset.nodeId;
                        const side = target.dataset.side;

                        if (reconnectingEnd === 'from') {
                            reconnectingConnection.from = nodeId;
                            reconnectingConnection.fromSide = side;
                        } else { // 'to'
                            reconnectingConnection.to = nodeId;
                            reconnectingConnection.toSide = side;
                        }
                    }
                    drawConnections(); // Redraw to snap back or to new position
                }

                if (isSelecting) {
                    const selectionRect = selectionBox.getBoundingClientRect();

                    diagramData.nodes.forEach(node => {
                        const nodeEl = appState.nodesById[node.id];
                        if (nodeEl) {
                            const nodeRect = nodeEl.getBoundingClientRect();
                            // Check for intersection
                            const intersects = !(
                                selectionRect.right < nodeRect.left ||
                                selectionRect.left > nodeRect.right ||
                                selectionRect.bottom < nodeRect.top ||
                                selectionRect.top > nodeRect.bottom
                            );
                            if (intersects) {
                                addNodeToSelection(node.id);
                            }
                        }
                    });

                    container.removeChild(selectionBox);
                    appState.interaction.isSelecting = false;
                    appState.interaction.selectionBox = null;
                }

                if (isDragging || isResizing) {
                    // One final render to make sure everything is in place
                    renderSceneUpdate();
                }

                if (isResizing) {
                    appState.interaction.resizingNode.classList.remove(CONFIG.CSS_CLASSES.NODE_RESIZING);
                    appState.interaction.isResizing = false;
                    appState.interaction.resizingNode = null;
                    appState.interaction.resizeHandle = '';
                }

                const clickedNodeData = draggedNode ? diagramData.nodes.find(n => n.id === draggedNode.id) : null;

                if (isConnecting && clickedNodeData && connectionStartNodeId !== clickedNodeData.id) {
                    // Finalize connection
                    const newConnection = { from: connectionStartNodeId, to: clickedNodeData.id, type: 'solid', color: 'green', arrow: 'to' };
                    diagramData.connections.push(newConnection);
                    drawConnections();
                } else if (draggedNode && !isDragging) { // This is a click on a node
                    const targetNode = e.target.closest('.node');
                    // Check if the click ended on the same node it started on
                    if (targetNode && targetNode.id === draggedNode.id) {
                        const target = e.target;
                        if (target.classList.contains('node-title') || target.classList.contains('node-description')) {
                            hideTooltip();
                            target.contentEditable = true;
                            target.style.userSelect = 'text';
                            target.focus();
                            // Select all text for easier editing
                            const selection = window.getSelection();
                            const range = document.createRange();
                            range.selectNodeContents(target);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        } else {
                            showTooltip(e, clickedNodeData);
                        }
                    }
                }

                if (draggedNode) {
                    draggedNode.style.cursor = 'grab';
                    if (isDragging) {
                        appState.interaction.selectedNodes.forEach(id => {
                            appState.nodesById[id]?.classList.remove(CONFIG.CSS_CLASSES.NODE_DRAGGING);
                        });
                    }
                }

                // Reset interaction state
                appState.interaction.isPanning = false;
                appState.interaction.isDragging = false;
                appState.interaction.draggedNode = null;
                appState.interaction.dragStartPositions.clear();
                appState.interaction.isReconnecting = false;
                appState.interaction.reconnectingConnection = null;
                appState.interaction.reconnectingEnd = null;
                appState.interaction.isConnecting = false;
                appState.interaction.connectionStartNodeId = null;
                container.style.cursor = 'default';

                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            function hideTooltip() {
                tooltip.classList.add(CONFIG.CSS_CLASSES.TOOLTIP_HIDDEN);
                tooltip.innerHTML = '';
                appState.interaction.selectedItem = null;
                hideColorPalette();
            }

            function hideContextMenu() {
                contextMenu.classList.add(CONFIG.CSS_CLASSES.CONTEXT_MENU_HIDDEN);
                hideColorPalette();
            }

            function showTooltip(e, item) {
                hideTooltip();
                appState.interaction.selectedItem = item;
                tooltip.classList.remove(CONFIG.CSS_CLASSES.TOOLTIP_HIDDEN);

                const availableColors = Object.keys(lineColors);

                if (item.hasOwnProperty('title')) { // Is a node
                    populateNodeTooltip(item, availableColors);
                    const nodeEl = appState.nodesById[item.id];
                    const nodeRect = nodeEl.getBoundingClientRect();
                    tooltip.style.left = `${nodeRect.left}px`;
                    tooltip.style.top = `${nodeRect.bottom + 10}px`;
                } else { // Is a connection
                    populateConnectionTooltip(item, availableColors);
                    tooltip.style.left = `${e.clientX}px`;
                    tooltip.style.top = `${e.clientY}px`;
                }
            }

            function populateNodeTooltip(node, colors) {
                const colorSection = createElement('div', { className: 'tooltip-section' });
                const mainSwatch = createElement('div', {
                    className: 'color-swatch',
                    onClick: (e) => {
                        e.stopPropagation();
                        showColorPalette(mainSwatch, node, colors, true);
                    }
                });
                mainSwatch.style.backgroundColor = lineColors[node.color] || '#4B5563';
                colorSection.appendChild(mainSwatch);
                tooltip.appendChild(colorSection);

                // Style Section
                const styleSection = createElement('div', { className: 'tooltip-section' });
                ['default', 'border', 'filled'].forEach(styleName => {
                    const btn = createElement('button', {
                        className: `tooltip-button ${(node.style || 'default') === styleName ? CONFIG.CSS_CLASSES.BUTTON_ACTIVE : ''}`,
                        textContent: styleName.charAt(0).toUpperCase() + styleName.slice(1),
                        onClick: (e) => {
                            const nodesToUpdateIds = appState.interaction.selectedNodes.has(node.id)
                                ? [...appState.interaction.selectedNodes]
                                : [node.id];

                            nodesToUpdateIds.forEach(nodeId => {
                                const nodeData = diagramData.nodes.find(n => n.id === nodeId);
                                const nodeEl = appState.nodesById[nodeId];

                                if (nodeData && nodeEl) {
                                    if (nodeData.style && nodeData.style !== 'default') {
                                        nodeEl.classList.remove(`style-${nodeData.style}`);
                                    }
                                    nodeData.style = styleName;
                                    if (styleName !== 'default') {
                                        nodeEl.classList.add(`style-${styleName}`);
                                    }
                                }
                            });

                            const parent = e.target.parentElement;
                            Array.from(parent.children).forEach(child => child.classList.remove(CONFIG.CSS_CLASSES.BUTTON_ACTIVE));
                            e.target.classList.add(CONFIG.CSS_CLASSES.BUTTON_ACTIVE);
                        }
                    });
                    styleSection.appendChild(btn);
                });
                tooltip.appendChild(styleSection);

                // Actions Section
                const actionsSection = createElement('div', { className: 'tooltip-section' });

                const connectBtn = createElement('button', {
                    className: 'tooltip-button',
                    textContent: 'Conectar',
                    onClick: () => {
                        appState.interaction.isConnecting = true;
                        appState.interaction.connectionStartNodeId = node.id;
                        container.style.cursor = 'crosshair';
                        hideTooltip();
                    }
                });
                actionsSection.appendChild(connectBtn);

                const deleteBtn = createElement('button', {
                    className: 'tooltip-button delete',
                    textContent: 'Deletar',
                    onClick: () => {
                        // Remove node
                        diagramData.nodes = diagramData.nodes.filter(n => n.id !== node.id);
                        // Remove associated connections
                        diagramData.connections = diagramData.connections.filter(c => c.from !== node.id && c.to !== node.id);
                        hideTooltip();
                        initializeDiagram();
                    }
                });
                actionsSection.appendChild(deleteBtn);

                tooltip.appendChild(actionsSection);
            }

            function populateConnectionTooltip(conn, colors) {
                // Color section
                const colorSection = createElement('div', { className: 'tooltip-section' });
                const mainSwatch = createElement('div', {
                    className: 'color-swatch',
                    onClick: (e) => {
                        e.stopPropagation();
                        showColorPalette(mainSwatch, conn, colors, false);
                    }
                });
                mainSwatch.style.backgroundColor = lineColors[conn.color] || '#4B5563';
                colorSection.appendChild(mainSwatch);
                tooltip.appendChild(colorSection);

                // Style section
                const styleSection = createElement('div', { className: 'tooltip-section' });
                ['solid', 'dashed'].forEach(style => {
                    const btn = createElement('button', {
                        className: `tooltip-button ${conn.type === style ? CONFIG.CSS_CLASSES.BUTTON_ACTIVE : ''}`,
                        textContent: style.charAt(0).toUpperCase() + style.slice(1),
                        onClick: () => {
                            conn.type = style;
                            drawConnections();
                            const tempEvent = { clientX: parseInt(tooltip.style.left), clientY: parseInt(tooltip.style.top) };
                            showTooltip(tempEvent, conn);
                        }
                    });
                    styleSection.appendChild(btn);
                });
                tooltip.appendChild(styleSection);

                // Arrow section
                const arrowSection = createElement('div', { className: 'tooltip-section' });
                ['none', 'from', 'to', 'both'].forEach(dir => {
                    const btn = createElement('button', {
                        className: `tooltip-button ${(conn.arrow || 'none') === dir ? CONFIG.CSS_CLASSES.BUTTON_ACTIVE : ''}`,
                        textContent: dir.charAt(0).toUpperCase() + dir.slice(1),
                        onClick: () => {
                            conn.arrow = dir;
                            drawConnections();
                            const tempEvent = { clientX: parseInt(tooltip.style.left), clientY: parseInt(tooltip.style.top) };
                            showTooltip(tempEvent, conn);
                        }
                    });
                    arrowSection.appendChild(btn);
                });
                tooltip.appendChild(arrowSection);

                // Delete Button Section
                const deleteSection = createElement('div', { className: 'tooltip-section' });
                const deleteBtn = createElement('button', {
                    className: 'tooltip-button delete',
                    textContent: 'Deletar',
                    onClick: () => {
                        diagramData.connections = diagramData.connections.filter(c => c !== conn);
                        hideTooltip();
                        drawConnections();
                    }
                });
                deleteSection.appendChild(deleteBtn);
                tooltip.appendChild(deleteSection);
            }

            function hideColorPalette() {
                colorPalette.classList.add('hidden');
                colorPalette.innerHTML = '';
            }

            function showColorPalette(targetEl, item, colors, isNode) {
                hideColorPalette(); // Close any existing one
                colorPalette.classList.remove('hidden');

                const targetRect = targetEl.getBoundingClientRect();
                colorPalette.style.left = `${targetRect.right + 8}px`;
                colorPalette.style.top = `${targetRect.top - 8}px`;

                colors.forEach(colorName => {
                    const swatch = createElement('div', {
                        className: 'color-swatch',
                        onClick: () => {
                            if (isNode) {
                                const nodesToUpdateIds = appState.interaction.selectedNodes.has(item.id)
                                    ? [...appState.interaction.selectedNodes]
                                    : [item.id];

                                nodesToUpdateIds.forEach(nodeId => {
                                    const nodeData = diagramData.nodes.find(n => n.id === nodeId);
                                    const nodeEl = appState.nodesById[nodeId];

                                    if (nodeData && nodeEl) {
                                        const oldColor = nodeData.color;
                                        if (oldColor) nodeEl.classList.remove(`color-${oldColor}`);

                                        nodeData.color = colorName;
                                        nodeEl.classList.add(`color-${colorName}`);
                                    }
                                });
                            } else { // It's a connection
                                item.color = colorName;
                                drawConnections();
                            }

                            targetEl.style.backgroundColor = lineColors[colorName];
                            hideColorPalette();
                        }
                    });
                    swatch.style.backgroundColor = lineColors[colorName];
                    colorPalette.appendChild(swatch);
                });

                // Hide palette on outside click
                setTimeout(() => {
                    const outsideClickListener = (event) => {
                        if (!colorPalette.contains(event.target) && event.target !== targetEl) {
                            hideColorPalette();
                            document.removeEventListener('click', outsideClickListener, true);
                        }
                    };
                    document.addEventListener('click', outsideClickListener, true);
                }, 0);
            }

            function exportDiagram() {
                const exportableData = {
                    nodes: diagramData.nodes,
                    connections: diagramData.connections.map(({ _renderData, ...conn }) => conn)
                };
                const dataStr = JSON.stringify(exportableData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'diagram.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            function importDiagram(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (importedData && Array.isArray(importedData.nodes) && Array.isArray(importedData.connections)) {
                            diagramData.nodes = importedData.nodes;
                            diagramData.connections = importedData.connections;
                            clearSelection();
                            initializeDiagram();
                        } else {
                            alert('Arquivo JSON inválido ou mal formatado.');
                        }
                    } catch (error) {
                        alert('Erro ao ler o arquivo JSON: ' + error.message);
                    }
                    event.target.value = ''; // Reset input
                };
                reader.readAsText(file);
            }

            function createNodeAtPosition(clientX, clientY) {
                const { x, y } = getCanvasPercentCoords(clientX, clientY);

                const newNode = {
                    id: `node_${Date.now()}`,
                    title: 'Novo Card',
                    description: 'Clique para editar o texto.',
                    x: x,
                    y: y,
                    color: 'green'
                };

                diagramData.nodes.push(newNode);
                initializeDiagram();
            }

            function getCanvasPoint(event) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }

            // Function to check distance from a point to a line segment
            function distToSegmentSquared(p, v, w) {
                const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
                if (l2 == 0) return (p.x - v.x) ** 2 + (p.y - v.y) ** 2;
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return (p.x - (v.x + t * (w.x - v.x))) ** 2 + (p.y - (v.y + t * (w.y - v.y))) ** 2;
            }

            function isPointOnBezier(p, start, cp1, cp2, end, threshold) {
                const samples = 20;
                let prevPoint = start;
                for (let i = 1; i <= samples; i++) {
                    const t = i / samples;
                    const invT = 1 - t;
                    const x = invT ** 3 * start.x + 3 * invT ** 2 * t * cp1.x + 3 * invT * t ** 2 * cp2.x + t ** 3 * end.x;
                    const y = invT ** 3 * start.y + 3 * invT ** 2 * t * cp1.y + 3 * invT * t ** 2 * cp2.y + t ** 3 * end.y;
                    const currentPoint = { x, y };
                    if (distToSegmentSquared(p, prevPoint, currentPoint) < threshold ** 2) {
                        return true;
                    }
                    prevPoint = currentPoint;
                }
                return false;
            }

            container.addEventListener('mousedown', (e) => {
                // Background click
                if (e.target === container || e.target === canvas) {
                    if (e.button === 0) { // Left click for selection
                        hideTooltip();
                        hideContextMenu();
                        clearSelection();

                        appState.interaction.isSelecting = true;
                        appState.interaction.selectionStart = getCanvasCoords(e.clientX, e.clientY);

                        const selectionBox = document.createElement('div');
                        selectionBox.className = 'selection-box';
                        container.appendChild(selectionBox);
                        appState.interaction.selectionBox = selectionBox;

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                        e.preventDefault();
                    }

                    if (appState.interaction.isConnecting) {
                        appState.interaction.isConnecting = false;
                        appState.interaction.connectionStartNodeId = null;
                        container.style.cursor = 'default';
                    }
                }
                // Pan with middle mouse button, only if not dragging a node.
                if (e.button === 1 && !appState.interaction.draggedNode) {
                    appState.interaction.isPanning = true;
                    appState.interaction.panStart.x = e.clientX - appState.view.panX;
                    appState.interaction.panStart.y = e.clientY - appState.view.panY;
                    container.style.cursor = 'grabbing';
                    e.preventDefault();
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                }
            });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;

                const point = getCanvasCoords(e.clientX, e.clientY);
                const threshold = CONFIG.CONNECTION_CLICK_THRESHOLD / appState.view.scale;

                for (const conn of diagramData.connections) {
                    if (conn._renderData) {
                        const rd = conn._renderData;
                        const startDist = Math.hypot(point.x - rd.startX, point.y - rd.startY);
                        const endDist = Math.hypot(point.x - rd.endX, point.y - rd.endY);

                        let endToDrag = null;
                        if (startDist < threshold) endToDrag = 'from';
                        else if (endDist < threshold) endToDrag = 'to';

                        if (endToDrag) {
                            e.stopPropagation();
                            e.preventDefault();

                            appState.interaction.isReconnecting = true;
                            appState.interaction.reconnectingConnection = conn;
                            appState.interaction.reconnectingEnd = endToDrag;

                            container.classList.add('is-reconnecting');
                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('mouseup', onMouseUp);
                            return;
                        }
                    }
                }
            });

            canvas.addEventListener('click', (e) => {
                const point = getCanvasCoords(e.clientX, e.clientY);
                const threshold = CONFIG.CONNECTION_CLICK_THRESHOLD / appState.view.scale; // Click tolerance in pixels

                let clickedConnection = null;
                // Iterate backwards so we click the top-most connection
                for (const conn of [...diagramData.connections].reverse()) {
                    if (conn._renderData) {
                        const rd = conn._renderData;
                        const start = { x: rd.startX, y: rd.startY };
                        const cp1 = { x: rd.cp1x, y: rd.cp1y };
                        const cp2 = { x: rd.cp2x, y: rd.cp2y };
                        const end = { x: rd.endX, y: rd.endY };
                        if (isPointOnBezier(point, start, cp1, cp2, end, threshold)) {
                            clickedConnection = conn;
                            break;
                        }
                    }
                }

                if (clickedConnection) {
                    showTooltip(e, clickedConnection);
                }
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const oldScale = appState.view.scale;

                if (e.deltaY < 0) {
                    appState.view.scale *= CONFIG.ZOOM_FACTOR;
                } else {
                    appState.view.scale /= CONFIG.ZOOM_FACTOR;
                }
                appState.view.scale = Math.max(0.2, Math.min(appState.view.scale, 5));

                appState.view.panX = mouseX - (mouseX - appState.view.panX) * (appState.view.scale / oldScale);
                appState.view.panY = mouseY - (mouseY - appState.view.panY) * (appState.view.scale / oldScale);

                updateTransform();
                drawConnections();
            }, { passive: false });

            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (appState.interaction.draggedNode || appState.interaction.isPanning || e.target.closest('.node')) return;

                hideTooltip();
                contextMenu.classList.remove(CONFIG.CSS_CLASSES.CONTEXT_MENU_HIDDEN);
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;

                contextMenu.innerHTML = ''; // Clear old items

                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                menuItem.textContent = 'Criar novo card';
                menuItem.onclick = () => {
                    createNodeAtPosition(e.clientX, e.clientY);
                    hideContextMenu();
                };
                contextMenu.appendChild(menuItem);
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (appState.interaction.isConnecting) {
                        appState.interaction.isConnecting = false;
                        appState.interaction.connectionStartNodeId = null;
                        container.style.cursor = 'default';
                    }
                    // Check if an editable element inside a node has focus
                    if (document.activeElement && document.activeElement.isContentEditable && document.activeElement.closest('.node')) {
                        document.activeElement.blur();
                    }
                }
            });

            function initializeDiagram() {
                appState.nodesById = {};
                updateTransform();
                renderNodes();
                setTimeout(drawConnections, 100);
            }

            window.addEventListener('resize', drawConnections);

            initDB(() => {
                loadDiagramState(() => {
                    initializeDiagram();
                });
            });

            document.getElementById('save-button').addEventListener('click', saveDiagramState);
            document.getElementById('export-button').addEventListener('click', exportDiagram);
            document.getElementById('import-file-input').addEventListener('change', importDiagram);
        });
    </script>
</body>

</html>
